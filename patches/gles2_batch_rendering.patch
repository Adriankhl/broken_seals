From 5313ef86744f3102ad78cb8231a2183af7d1fae1 Mon Sep 17 00:00:00 2001
From: lawnjelly <lawnjelly@gmail.com>
Date: Fri, 27 Mar 2020 09:19:37 +0000
Subject: [PATCH] GLES2 2d Batch rendering (across items)

2d rendering is currently bottlenecked by drawing primitives one at a time, limiting OpenGL efficiency. This PR batches primitives and renders in fewer drawcalls, resulting in significant performance improvements. This also speeds up text rendering.

This PR batches across canvas items as well as within items.

The code dynamically chooses between a vertex format with and without color, depending on the input data for a frame, in order to optimize throughput and maximize batch size.
---
 drivers/gles2/rasterizer_array.h              |  185 +
 .../gles2/rasterizer_canvas_base_gles2.cpp    | 1010 +++++
 drivers/gles2/rasterizer_canvas_base_gles2.h  |  140 +
 drivers/gles2/rasterizer_canvas_gles2.cpp     | 3666 ++++++++++-------
 drivers/gles2/rasterizer_canvas_gles2.h       |  300 +-
 servers/visual_server.cpp                     |    1 +
 6 files changed, 3611 insertions(+), 1691 deletions(-)
 create mode 100644 drivers/gles2/rasterizer_array.h
 create mode 100644 drivers/gles2/rasterizer_canvas_base_gles2.cpp
 create mode 100644 drivers/gles2/rasterizer_canvas_base_gles2.h

diff --git a/drivers/gles2/rasterizer_array.h b/drivers/gles2/rasterizer_array.h
new file mode 100644
index 00000000000..429e76945c5
--- /dev/null
+++ b/drivers/gles2/rasterizer_array.h
@@ -0,0 +1,185 @@
+#pragma once
+
+/*************************************************************************/
+/*  rasterizer_array.h                                                   */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                      https://godotengine.org                          */
+/*************************************************************************/
+/* Copyright (c) 2007-2020 Juan Linietsky, Ariel Manzur.                 */
+/* Copyright (c) 2014-2020 Godot Engine contributors (cf. AUTHORS.md).   */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+
+/**
+ * Fast single-threaded growable array for POD types.
+ * For use in render drivers, not for general use.
+*/
+
+#include "core/os/memory.h"
+#include "core/vector.h"
+
+#include <string.h>
+
+template <class T>
+class RasterizerArray {
+public:
+	RasterizerArray() {
+		_list = 0;
+		_size = 0;
+		_max_size = 0;
+	}
+	~RasterizerArray() { free(); }
+
+	T &operator[](unsigned int ui) { return _list[ui]; }
+	const T &operator[](unsigned int ui) const { return _list[ui]; }
+
+	void free() {
+		if (_list) {
+			memdelete_arr(_list);
+			_list = 0;
+		}
+		_size = 0;
+		_max_size = 0;
+	}
+
+	void create(int p_size) {
+		free();
+		_list = memnew_arr(T, p_size);
+		_size = 0;
+		_max_size = p_size;
+	}
+
+	void reset() { _size = 0; }
+
+	T *request_with_grow() {
+		T *p = request();
+		if (!p) {
+			grow();
+			return request_with_grow();
+		}
+		return p;
+	}
+
+	// none of that inefficient pass by value stuff here, thanks
+	T *request() {
+		if (_size < _max_size) {
+			return &_list[_size++];
+		}
+		return 0;
+	}
+
+	// four verts at a time
+	T *request_four() {
+		int old_size = _size;
+		_size += 4;
+
+		if (_size <= _max_size) {
+			return &_list[old_size];
+		}
+
+		// revert
+		_size = old_size;
+		return 0;
+	}
+
+	int size() const { return _size; }
+	int max_size() const { return _max_size; }
+	const T *get_data() const { return _list; }
+
+	bool copy_from(const RasterizerArray<T> &o) {
+		// no resizing done here, it should be done manually
+		if (o.size() > _max_size)
+			return false;
+
+		// pod types only please!
+		memcpy(_list, o.get_data(), o.size() * sizeof(T));
+		_size = o.size();
+		return true;
+	}
+
+	// if you want this to be cheap, call reset before grow,
+	// to ensure there is no data to copy
+	void grow() {
+		unsigned int new_max_size = _max_size * 2;
+		if (!new_max_size)
+			new_max_size = 1;
+
+		T *new_list = memnew_arr(T, new_max_size);
+
+		// copy .. pod types only
+		memcpy(new_list, _list, _size * sizeof(T));
+
+		unsigned int new_size = size();
+		free();
+		_list = new_list;
+		_size = new_size;
+		_max_size = new_max_size;
+	}
+
+private:
+	T *_list;
+	int _size;
+	int _max_size;
+};
+
+template <class T>
+class RasterizerArray_non_pod {
+public:
+	RasterizerArray_non_pod() {
+		_size = 0;
+	}
+
+	const T &operator[](unsigned int ui) const { return _list[ui]; }
+
+	void create(int p_size) {
+		_list.resize(p_size);
+		_size = 0;
+	}
+	void reset() { _size = 0; }
+
+	void push_back(const T &val) {
+		while (true) {
+			if (_size < max_size()) {
+				_list.set(_size, val);
+				_size++;
+				return;
+			}
+
+			grow();
+		}
+	}
+
+	int size() const { return _size; }
+	int max_size() const { return _list.size(); }
+
+private:
+	void grow() {
+		unsigned int new_max_size = _list.size() * 2;
+		if (!new_max_size)
+			new_max_size = 1;
+		_list.resize(new_max_size);
+	}
+
+	Vector<T> _list;
+	int _size;
+};
diff --git a/drivers/gles2/rasterizer_canvas_base_gles2.cpp b/drivers/gles2/rasterizer_canvas_base_gles2.cpp
new file mode 100644
index 00000000000..86a109417a6
--- /dev/null
+++ b/drivers/gles2/rasterizer_canvas_base_gles2.cpp
@@ -0,0 +1,1010 @@
+/*************************************************************************/
+/*  rasterizer_canvas_base_gles2.cpp                                     */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                      https://godotengine.org                          */
+/*************************************************************************/
+/* Copyright (c) 2007-2020 Juan Linietsky, Ariel Manzur.                 */
+/* Copyright (c) 2014-2020 Godot Engine contributors (cf. AUTHORS.md).   */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+
+#include "rasterizer_canvas_base_gles2.h"
+
+#include "core/os/os.h"
+#include "core/project_settings.h"
+#include "rasterizer_scene_gles2.h"
+#include "servers/visual/visual_server_raster.h"
+
+#ifndef GLES_OVER_GL
+#define glClearDepth glClearDepthf
+#endif
+
+RID RasterizerCanvasBaseGLES2::light_internal_create() {
+
+	return RID();
+}
+
+void RasterizerCanvasBaseGLES2::light_internal_update(RID p_rid, Light *p_light) {
+}
+
+void RasterizerCanvasBaseGLES2::light_internal_free(RID p_rid) {
+}
+
+void RasterizerCanvasBaseGLES2::canvas_begin() {
+
+	state.canvas_shader.bind();
+	state.using_transparent_rt = false;
+	int viewport_x, viewport_y, viewport_width, viewport_height;
+
+	if (storage->frame.current_rt) {
+		glBindFramebuffer(GL_FRAMEBUFFER, storage->frame.current_rt->fbo);
+		state.using_transparent_rt = storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT];
+
+		if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_DIRECT_TO_SCREEN]) {
+			// set Viewport and Scissor when rendering directly to screen
+			viewport_width = storage->frame.current_rt->width;
+			viewport_height = storage->frame.current_rt->height;
+			viewport_x = storage->frame.current_rt->x;
+			viewport_y = OS::get_singleton()->get_window_size().height - viewport_height - storage->frame.current_rt->y;
+			glScissor(viewport_x, viewport_y, viewport_width, viewport_height);
+			glViewport(viewport_x, viewport_y, viewport_width, viewport_height);
+			glEnable(GL_SCISSOR_TEST);
+		}
+	}
+
+	if (storage->frame.clear_request) {
+		glClearColor(storage->frame.clear_request_color.r,
+				storage->frame.clear_request_color.g,
+				storage->frame.clear_request_color.b,
+				state.using_transparent_rt ? storage->frame.clear_request_color.a : 1.0);
+		glClear(GL_COLOR_BUFFER_BIT);
+		storage->frame.clear_request = false;
+	}
+
+	/*
+	if (storage->frame.current_rt) {
+		glBindFramebuffer(GL_FRAMEBUFFER, storage->frame.current_rt->fbo);
+		glColorMask(1, 1, 1, 1);
+	}
+	*/
+
+	reset_canvas();
+
+	glActiveTexture(GL_TEXTURE0);
+	glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
+
+	glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
+	glDisableVertexAttribArray(VS::ARRAY_COLOR);
+
+	// set up default uniforms
+
+	Transform canvas_transform;
+
+	if (storage->frame.current_rt) {
+
+		float csy = 1.0;
+		if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_VFLIP]) {
+			csy = -1.0;
+		}
+		canvas_transform.translate(-(storage->frame.current_rt->width / 2.0f), -(storage->frame.current_rt->height / 2.0f), 0.0f);
+		canvas_transform.scale(Vector3(2.0f / storage->frame.current_rt->width, csy * -2.0f / storage->frame.current_rt->height, 1.0f));
+	} else {
+		Vector2 ssize = OS::get_singleton()->get_window_size();
+		canvas_transform.translate(-(ssize.width / 2.0f), -(ssize.height / 2.0f), 0.0f);
+		canvas_transform.scale(Vector3(2.0f / ssize.width, -2.0f / ssize.height, 1.0f));
+	}
+
+	state.uniforms.projection_matrix = canvas_transform;
+
+	state.uniforms.final_modulate = Color(1, 1, 1, 1);
+
+	state.uniforms.modelview_matrix = Transform2D();
+	state.uniforms.extra_matrix = Transform2D();
+
+	_set_uniforms();
+	_bind_quad_buffer();
+}
+
+void RasterizerCanvasBaseGLES2::canvas_end() {
+
+	glBindBuffer(GL_ARRAY_BUFFER, 0);
+
+	for (int i = 0; i < VS::ARRAY_MAX; i++) {
+		glDisableVertexAttribArray(i);
+	}
+
+	if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_DIRECT_TO_SCREEN]) {
+		//reset viewport to full window size
+		int viewport_width = OS::get_singleton()->get_window_size().width;
+		int viewport_height = OS::get_singleton()->get_window_size().height;
+		glViewport(0, 0, viewport_width, viewport_height);
+		glScissor(0, 0, viewport_width, viewport_height);
+	}
+
+	state.using_texture_rect = false;
+	state.using_skeleton = false;
+	state.using_ninepatch = false;
+	state.using_transparent_rt = false;
+}
+
+void RasterizerCanvasBaseGLES2::draw_generic_textured_rect(const Rect2 &p_rect, const Rect2 &p_src) {
+
+	state.canvas_shader.set_uniform(CanvasShaderGLES2::DST_RECT, Color(p_rect.position.x, p_rect.position.y, p_rect.size.x, p_rect.size.y));
+	state.canvas_shader.set_uniform(CanvasShaderGLES2::SRC_RECT, Color(p_src.position.x, p_src.position.y, p_src.size.x, p_src.size.y));
+
+	glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+}
+
+RasterizerStorageGLES2::Texture *RasterizerCanvasBaseGLES2::_bind_canvas_texture(const RID &p_texture, const RID &p_normal_map) {
+
+	RasterizerStorageGLES2::Texture *tex_return = NULL;
+
+	if (p_texture.is_valid()) {
+
+		RasterizerStorageGLES2::Texture *texture = storage->texture_owner.getornull(p_texture);
+
+		if (!texture) {
+			state.current_tex = RID();
+			state.current_tex_ptr = NULL;
+
+			glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 1);
+			glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
+
+		} else {
+
+			if (texture->redraw_if_visible) {
+				VisualServerRaster::redraw_request();
+			}
+
+			texture = texture->get_ptr();
+
+			if (texture->render_target) {
+				texture->render_target->used_in_frame = true;
+			}
+
+			glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 1);
+			glBindTexture(GL_TEXTURE_2D, texture->tex_id);
+
+			state.current_tex = p_texture;
+			state.current_tex_ptr = texture;
+
+			tex_return = texture;
+		}
+	} else {
+		state.current_tex = RID();
+		state.current_tex_ptr = NULL;
+
+		glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 1);
+		glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
+	}
+
+	if (p_normal_map == state.current_normal) {
+		//do none
+		state.canvas_shader.set_uniform(CanvasShaderGLES2::USE_DEFAULT_NORMAL, state.current_normal.is_valid());
+
+	} else if (p_normal_map.is_valid()) {
+
+		RasterizerStorageGLES2::Texture *normal_map = storage->texture_owner.getornull(p_normal_map);
+
+		if (!normal_map) {
+			state.current_normal = RID();
+			glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 2);
+			glBindTexture(GL_TEXTURE_2D, storage->resources.normal_tex);
+			state.canvas_shader.set_uniform(CanvasShaderGLES2::USE_DEFAULT_NORMAL, false);
+
+		} else {
+
+			if (normal_map->redraw_if_visible) { //check before proxy, because this is usually used with proxies
+				VisualServerRaster::redraw_request();
+			}
+
+			normal_map = normal_map->get_ptr();
+
+			glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 2);
+			glBindTexture(GL_TEXTURE_2D, normal_map->tex_id);
+			state.current_normal = p_normal_map;
+			state.canvas_shader.set_uniform(CanvasShaderGLES2::USE_DEFAULT_NORMAL, true);
+		}
+
+	} else {
+
+		state.current_normal = RID();
+		glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 2);
+		glBindTexture(GL_TEXTURE_2D, storage->resources.normal_tex);
+		state.canvas_shader.set_uniform(CanvasShaderGLES2::USE_DEFAULT_NORMAL, false);
+	}
+
+	return tex_return;
+}
+
+void RasterizerCanvasBaseGLES2::draw_window_margins(int *black_margin, RID *black_image) {
+
+	Vector2 window_size = OS::get_singleton()->get_window_size();
+	int window_h = window_size.height;
+	int window_w = window_size.width;
+
+	glBindFramebuffer(GL_FRAMEBUFFER, storage->system_fbo);
+	glViewport(0, 0, window_size.width, window_size.height);
+	canvas_begin();
+
+	if (black_image[MARGIN_LEFT].is_valid()) {
+		_bind_canvas_texture(black_image[MARGIN_LEFT], RID());
+		Size2 sz(storage->texture_get_width(black_image[MARGIN_LEFT]), storage->texture_get_height(black_image[MARGIN_LEFT]));
+		draw_generic_textured_rect(Rect2(0, 0, black_margin[MARGIN_LEFT], window_h), Rect2(0, 0, sz.x, sz.y));
+	} else if (black_margin[MARGIN_LEFT]) {
+		glActiveTexture(GL_TEXTURE0);
+		glBindTexture(GL_TEXTURE_2D, storage->resources.black_tex);
+
+		draw_generic_textured_rect(Rect2(0, 0, black_margin[MARGIN_LEFT], window_h), Rect2(0, 0, 1, 1));
+	}
+
+	if (black_image[MARGIN_RIGHT].is_valid()) {
+		_bind_canvas_texture(black_image[MARGIN_RIGHT], RID());
+		Size2 sz(storage->texture_get_width(black_image[MARGIN_RIGHT]), storage->texture_get_height(black_image[MARGIN_RIGHT]));
+		draw_generic_textured_rect(Rect2(window_w - black_margin[MARGIN_RIGHT], 0, black_margin[MARGIN_RIGHT], window_h), Rect2(0, 0, sz.x, sz.y));
+	} else if (black_margin[MARGIN_RIGHT]) {
+		glActiveTexture(GL_TEXTURE0);
+		glBindTexture(GL_TEXTURE_2D, storage->resources.black_tex);
+
+		draw_generic_textured_rect(Rect2(window_w - black_margin[MARGIN_RIGHT], 0, black_margin[MARGIN_RIGHT], window_h), Rect2(0, 0, 1, 1));
+	}
+
+	if (black_image[MARGIN_TOP].is_valid()) {
+		_bind_canvas_texture(black_image[MARGIN_TOP], RID());
+
+		Size2 sz(storage->texture_get_width(black_image[MARGIN_TOP]), storage->texture_get_height(black_image[MARGIN_TOP]));
+		draw_generic_textured_rect(Rect2(0, 0, window_w, black_margin[MARGIN_TOP]), Rect2(0, 0, sz.x, sz.y));
+
+	} else if (black_margin[MARGIN_TOP]) {
+		glActiveTexture(GL_TEXTURE0);
+		glBindTexture(GL_TEXTURE_2D, storage->resources.black_tex);
+
+		draw_generic_textured_rect(Rect2(0, 0, window_w, black_margin[MARGIN_TOP]), Rect2(0, 0, 1, 1));
+	}
+
+	if (black_image[MARGIN_BOTTOM].is_valid()) {
+
+		_bind_canvas_texture(black_image[MARGIN_BOTTOM], RID());
+
+		Size2 sz(storage->texture_get_width(black_image[MARGIN_BOTTOM]), storage->texture_get_height(black_image[MARGIN_BOTTOM]));
+		draw_generic_textured_rect(Rect2(0, window_h - black_margin[MARGIN_BOTTOM], window_w, black_margin[MARGIN_BOTTOM]), Rect2(0, 0, sz.x, sz.y));
+
+	} else if (black_margin[MARGIN_BOTTOM]) {
+
+		glActiveTexture(GL_TEXTURE0);
+		glBindTexture(GL_TEXTURE_2D, storage->resources.black_tex);
+
+		draw_generic_textured_rect(Rect2(0, window_h - black_margin[MARGIN_BOTTOM], window_w, black_margin[MARGIN_BOTTOM]), Rect2(0, 0, 1, 1));
+	}
+
+	canvas_end();
+}
+
+void RasterizerCanvasBaseGLES2::_bind_quad_buffer() {
+	glBindBuffer(GL_ARRAY_BUFFER, data.canvas_quad_vertices);
+	glEnableVertexAttribArray(VS::ARRAY_VERTEX);
+	glVertexAttribPointer(VS::ARRAY_VERTEX, 2, GL_FLOAT, GL_FALSE, 0, NULL);
+}
+
+void RasterizerCanvasBaseGLES2::_set_uniforms() {
+
+	state.canvas_shader.set_uniform(CanvasShaderGLES2::PROJECTION_MATRIX, state.uniforms.projection_matrix);
+	state.canvas_shader.set_uniform(CanvasShaderGLES2::MODELVIEW_MATRIX, state.uniforms.modelview_matrix);
+	state.canvas_shader.set_uniform(CanvasShaderGLES2::EXTRA_MATRIX, state.uniforms.extra_matrix);
+
+	state.canvas_shader.set_uniform(CanvasShaderGLES2::FINAL_MODULATE, state.uniforms.final_modulate);
+
+	state.canvas_shader.set_uniform(CanvasShaderGLES2::TIME, storage->frame.time[0]);
+
+	if (storage->frame.current_rt) {
+		Vector2 screen_pixel_size;
+		screen_pixel_size.x = 1.0 / storage->frame.current_rt->width;
+		screen_pixel_size.y = 1.0 / storage->frame.current_rt->height;
+
+		state.canvas_shader.set_uniform(CanvasShaderGLES2::SCREEN_PIXEL_SIZE, screen_pixel_size);
+	}
+
+	if (state.using_skeleton) {
+		state.canvas_shader.set_uniform(CanvasShaderGLES2::SKELETON_TRANSFORM, state.skeleton_transform);
+		state.canvas_shader.set_uniform(CanvasShaderGLES2::SKELETON_TRANSFORM_INVERSE, state.skeleton_transform_inverse);
+		state.canvas_shader.set_uniform(CanvasShaderGLES2::SKELETON_TEXTURE_SIZE, state.skeleton_texture_size);
+	}
+
+	if (state.using_light) {
+
+		Light *light = state.using_light;
+		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_MATRIX, light->light_shader_xform);
+		Transform2D basis_inverse = light->light_shader_xform.affine_inverse().orthonormalized();
+		basis_inverse[2] = Vector2();
+		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_MATRIX_INVERSE, basis_inverse);
+		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_LOCAL_MATRIX, light->xform_cache.affine_inverse());
+		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_COLOR, light->color * light->energy);
+		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_POS, light->light_shader_pos);
+		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_HEIGHT, light->height);
+		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_OUTSIDE_ALPHA, light->mode == VS::CANVAS_LIGHT_MODE_MASK ? 1.0 : 0.0);
+
+		if (state.using_shadow) {
+			RasterizerStorageGLES2::CanvasLightShadow *cls = storage->canvas_light_shadow_owner.get(light->shadow_buffer);
+			glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 5);
+			glBindTexture(GL_TEXTURE_2D, cls->distance);
+			state.canvas_shader.set_uniform(CanvasShaderGLES2::SHADOW_MATRIX, light->shadow_matrix_cache);
+			state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_SHADOW_COLOR, light->shadow_color);
+
+			state.canvas_shader.set_uniform(CanvasShaderGLES2::SHADOWPIXEL_SIZE, (1.0 / light->shadow_buffer_size) * (1.0 + light->shadow_smooth));
+			if (light->radius_cache == 0) {
+				state.canvas_shader.set_uniform(CanvasShaderGLES2::SHADOW_GRADIENT, 0.0);
+			} else {
+				state.canvas_shader.set_uniform(CanvasShaderGLES2::SHADOW_GRADIENT, light->shadow_gradient_length / (light->radius_cache * 1.1));
+			}
+			state.canvas_shader.set_uniform(CanvasShaderGLES2::SHADOW_DISTANCE_MULT, light->radius_cache * 1.1);
+
+			/*canvas_shader.set_uniform(CanvasShaderGLES2::SHADOW_MATRIX,light->shadow_matrix_cache);
+			canvas_shader.set_uniform(CanvasShaderGLES2::SHADOW_ESM_MULTIPLIER,light->shadow_esm_mult);
+			canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_SHADOW_COLOR,light->shadow_color);*/
+		}
+	}
+}
+
+void RasterizerCanvasBaseGLES2::reset_canvas() {
+
+	glDisable(GL_CULL_FACE);
+	glDisable(GL_DEPTH_TEST);
+	glDisable(GL_SCISSOR_TEST);
+	glDisable(GL_DITHER);
+	glEnable(GL_BLEND);
+
+	if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
+		glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+	} else {
+		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	}
+
+	// bind the back buffer to a texture so shaders can use it.
+	// It should probably use texture unit -3 (as GLES2 does as well) but currently that's buggy.
+	// keeping this for now as there's nothing else that uses texture unit 2
+	// TODO ^
+	if (storage->frame.current_rt) {
+		// glActiveTexture(GL_TEXTURE0 + 2);
+		// glBindTexture(GL_TEXTURE_2D, storage->frame.current_rt->copy_screen_effect.color);
+	}
+
+	glBindBuffer(GL_ARRAY_BUFFER, 0);
+	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+}
+
+void RasterizerCanvasBaseGLES2::canvas_debug_viewport_shadows(Light *p_lights_with_shadow) {
+}
+
+void RasterizerCanvasBaseGLES2::_copy_texscreen(const Rect2 &p_rect) {
+
+	state.canvas_texscreen_used = true;
+
+	_copy_screen(p_rect);
+
+	// back to canvas, force rebind
+	state.using_texture_rect = false;
+	state.canvas_shader.bind();
+	_bind_canvas_texture(state.current_tex, state.current_normal);
+	_set_uniforms();
+}
+
+void RasterizerCanvasBaseGLES2::_draw_polygon(const int *p_indices, int p_index_count, int p_vertex_count, const Vector2 *p_vertices, const Vector2 *p_uvs, const Color *p_colors, bool p_singlecolor, const float *p_weights, const int *p_bones) {
+
+	glBindBuffer(GL_ARRAY_BUFFER, data.polygon_buffer);
+#ifndef GLES_OVER_GL
+	// Orphan the buffer to avoid CPU/GPU sync points caused by glBufferSubData
+	glBufferData(GL_ARRAY_BUFFER, data.polygon_buffer_size, NULL, GL_DYNAMIC_DRAW);
+#endif
+
+	uint32_t buffer_ofs = 0;
+
+	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(Vector2) * p_vertex_count, p_vertices);
+	glEnableVertexAttribArray(VS::ARRAY_VERTEX);
+	glVertexAttribPointer(VS::ARRAY_VERTEX, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2), NULL);
+	buffer_ofs += sizeof(Vector2) * p_vertex_count;
+
+	if (p_singlecolor) {
+		glDisableVertexAttribArray(VS::ARRAY_COLOR);
+		Color m = *p_colors;
+		glVertexAttrib4f(VS::ARRAY_COLOR, m.r, m.g, m.b, m.a);
+	} else if (!p_colors) {
+		glDisableVertexAttribArray(VS::ARRAY_COLOR);
+		glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
+	} else {
+		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(Color) * p_vertex_count, p_colors);
+		glEnableVertexAttribArray(VS::ARRAY_COLOR);
+		glVertexAttribPointer(VS::ARRAY_COLOR, 4, GL_FLOAT, GL_FALSE, sizeof(Color), CAST_INT_TO_UCHAR_PTR(buffer_ofs));
+		buffer_ofs += sizeof(Color) * p_vertex_count;
+	}
+
+	if (p_uvs) {
+		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(Vector2) * p_vertex_count, p_uvs);
+		glEnableVertexAttribArray(VS::ARRAY_TEX_UV);
+		glVertexAttribPointer(VS::ARRAY_TEX_UV, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2), CAST_INT_TO_UCHAR_PTR(buffer_ofs));
+		buffer_ofs += sizeof(Vector2) * p_vertex_count;
+	} else {
+		glDisableVertexAttribArray(VS::ARRAY_TEX_UV);
+	}
+
+	if (p_weights && p_bones) {
+		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(float) * 4 * p_vertex_count, p_weights);
+		glEnableVertexAttribArray(VS::ARRAY_WEIGHTS);
+		glVertexAttribPointer(VS::ARRAY_WEIGHTS, 4, GL_FLOAT, GL_FALSE, sizeof(float) * 4, CAST_INT_TO_UCHAR_PTR(buffer_ofs));
+		buffer_ofs += sizeof(float) * 4 * p_vertex_count;
+
+		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(int) * 4 * p_vertex_count, p_bones);
+		glEnableVertexAttribArray(VS::ARRAY_BONES);
+		glVertexAttribPointer(VS::ARRAY_BONES, 4, GL_UNSIGNED_INT, GL_FALSE, sizeof(int) * 4, CAST_INT_TO_UCHAR_PTR(buffer_ofs));
+		buffer_ofs += sizeof(int) * 4 * p_vertex_count;
+
+	} else {
+		glDisableVertexAttribArray(VS::ARRAY_WEIGHTS);
+		glDisableVertexAttribArray(VS::ARRAY_BONES);
+	}
+
+	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, data.polygon_index_buffer);
+#ifndef GLES_OVER_GL
+	// Orphan the buffer to avoid CPU/GPU sync points caused by glBufferSubData
+	glBufferData(GL_ELEMENT_ARRAY_BUFFER, data.polygon_index_buffer_size, NULL, GL_DYNAMIC_DRAW);
+#endif
+
+	if (storage->config.support_32_bits_indices) { //should check for
+		glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, 0, sizeof(int) * p_index_count, p_indices);
+		glDrawElements(GL_TRIANGLES, p_index_count, GL_UNSIGNED_INT, 0);
+	} else {
+		uint16_t *index16 = (uint16_t *)alloca(sizeof(uint16_t) * p_index_count);
+		for (int i = 0; i < p_index_count; i++) {
+			index16[i] = uint16_t(p_indices[i]);
+		}
+		glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, 0, sizeof(uint16_t) * p_index_count, index16);
+		glDrawElements(GL_TRIANGLES, p_index_count, GL_UNSIGNED_SHORT, 0);
+	}
+
+	glBindBuffer(GL_ARRAY_BUFFER, 0);
+	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+}
+
+void RasterizerCanvasBaseGLES2::_draw_generic(GLuint p_primitive, int p_vertex_count, const Vector2 *p_vertices, const Vector2 *p_uvs, const Color *p_colors, bool p_singlecolor) {
+
+	glBindBuffer(GL_ARRAY_BUFFER, data.polygon_buffer);
+#ifndef GLES_OVER_GL
+	// Orphan the buffer to avoid CPU/GPU sync points caused by glBufferSubData
+	glBufferData(GL_ARRAY_BUFFER, data.polygon_buffer_size, NULL, GL_DYNAMIC_DRAW);
+#endif
+
+	uint32_t buffer_ofs = 0;
+
+	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(Vector2) * p_vertex_count, p_vertices);
+	glEnableVertexAttribArray(VS::ARRAY_VERTEX);
+	glVertexAttribPointer(VS::ARRAY_VERTEX, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2), NULL);
+	buffer_ofs += sizeof(Vector2) * p_vertex_count;
+
+	if (p_singlecolor) {
+		glDisableVertexAttribArray(VS::ARRAY_COLOR);
+		Color m = *p_colors;
+		glVertexAttrib4f(VS::ARRAY_COLOR, m.r, m.g, m.b, m.a);
+	} else if (!p_colors) {
+		glDisableVertexAttribArray(VS::ARRAY_COLOR);
+		glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
+	} else {
+		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(Color) * p_vertex_count, p_colors);
+		glEnableVertexAttribArray(VS::ARRAY_COLOR);
+		glVertexAttribPointer(VS::ARRAY_COLOR, 4, GL_FLOAT, GL_FALSE, sizeof(Color), CAST_INT_TO_UCHAR_PTR(buffer_ofs));
+		buffer_ofs += sizeof(Color) * p_vertex_count;
+	}
+
+	if (p_uvs) {
+		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(Vector2) * p_vertex_count, p_uvs);
+		glEnableVertexAttribArray(VS::ARRAY_TEX_UV);
+		glVertexAttribPointer(VS::ARRAY_TEX_UV, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2), CAST_INT_TO_UCHAR_PTR(buffer_ofs));
+	} else {
+		glDisableVertexAttribArray(VS::ARRAY_TEX_UV);
+	}
+
+	glDrawArrays(p_primitive, 0, p_vertex_count);
+
+	glBindBuffer(GL_ARRAY_BUFFER, 0);
+}
+
+void RasterizerCanvasBaseGLES2::_draw_generic_indices(GLuint p_primitive, const int *p_indices, int p_index_count, int p_vertex_count, const Vector2 *p_vertices, const Vector2 *p_uvs, const Color *p_colors, bool p_singlecolor) {
+
+	glBindBuffer(GL_ARRAY_BUFFER, data.polygon_buffer);
+#ifndef GLES_OVER_GL
+	// Orphan the buffer to avoid CPU/GPU sync points caused by glBufferSubData
+	glBufferData(GL_ARRAY_BUFFER, data.polygon_buffer_size, NULL, GL_DYNAMIC_DRAW);
+#endif
+
+	uint32_t buffer_ofs = 0;
+
+	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(Vector2) * p_vertex_count, p_vertices);
+	glEnableVertexAttribArray(VS::ARRAY_VERTEX);
+	glVertexAttribPointer(VS::ARRAY_VERTEX, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2), NULL);
+	buffer_ofs += sizeof(Vector2) * p_vertex_count;
+
+	if (p_singlecolor) {
+		glDisableVertexAttribArray(VS::ARRAY_COLOR);
+		Color m = *p_colors;
+		glVertexAttrib4f(VS::ARRAY_COLOR, m.r, m.g, m.b, m.a);
+	} else if (!p_colors) {
+		glDisableVertexAttribArray(VS::ARRAY_COLOR);
+		glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
+	} else {
+		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(Color) * p_vertex_count, p_colors);
+		glEnableVertexAttribArray(VS::ARRAY_COLOR);
+		glVertexAttribPointer(VS::ARRAY_COLOR, 4, GL_FLOAT, GL_FALSE, sizeof(Color), CAST_INT_TO_UCHAR_PTR(buffer_ofs));
+		buffer_ofs += sizeof(Color) * p_vertex_count;
+	}
+
+	if (p_uvs) {
+		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(Vector2) * p_vertex_count, p_uvs);
+		glEnableVertexAttribArray(VS::ARRAY_TEX_UV);
+		glVertexAttribPointer(VS::ARRAY_TEX_UV, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2), CAST_INT_TO_UCHAR_PTR(buffer_ofs));
+		buffer_ofs += sizeof(Vector2) * p_vertex_count;
+	} else {
+		glDisableVertexAttribArray(VS::ARRAY_TEX_UV);
+	}
+
+	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, data.polygon_index_buffer);
+#ifndef GLES_OVER_GL
+	// Orphan the buffer to avoid CPU/GPU sync points caused by glBufferSubData
+	glBufferData(GL_ELEMENT_ARRAY_BUFFER, data.polygon_index_buffer_size, NULL, GL_DYNAMIC_DRAW);
+#endif
+
+	if (storage->config.support_32_bits_indices) { //should check for
+		glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, 0, sizeof(int) * p_index_count, p_indices);
+		glDrawElements(p_primitive, p_index_count, GL_UNSIGNED_INT, 0);
+	} else {
+		uint16_t *index16 = (uint16_t *)alloca(sizeof(uint16_t) * p_index_count);
+		for (int i = 0; i < p_index_count; i++) {
+			index16[i] = uint16_t(p_indices[i]);
+		}
+		glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, 0, sizeof(uint16_t) * p_index_count, index16);
+		glDrawElements(p_primitive, p_index_count, GL_UNSIGNED_SHORT, 0);
+	}
+
+	glBindBuffer(GL_ARRAY_BUFFER, 0);
+	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+}
+
+void RasterizerCanvasBaseGLES2::_draw_gui_primitive(int p_points, const Vector2 *p_vertices, const Color *p_colors, const Vector2 *p_uvs) {
+
+	static const GLenum prim[5] = { GL_POINTS, GL_POINTS, GL_LINES, GL_TRIANGLES, GL_TRIANGLE_FAN };
+
+	int color_offset = 0;
+	int uv_offset = 0;
+	int stride = 2;
+
+	if (p_colors) {
+		color_offset = stride;
+		stride += 4;
+	}
+
+	if (p_uvs) {
+		uv_offset = stride;
+		stride += 2;
+	}
+
+	float buffer_data[(2 + 2 + 4) * 4];
+
+	for (int i = 0; i < p_points; i++) {
+		buffer_data[stride * i + 0] = p_vertices[i].x;
+		buffer_data[stride * i + 1] = p_vertices[i].y;
+	}
+
+	if (p_colors) {
+		for (int i = 0; i < p_points; i++) {
+			buffer_data[stride * i + color_offset + 0] = p_colors[i].r;
+			buffer_data[stride * i + color_offset + 1] = p_colors[i].g;
+			buffer_data[stride * i + color_offset + 2] = p_colors[i].b;
+			buffer_data[stride * i + color_offset + 3] = p_colors[i].a;
+		}
+	}
+
+	if (p_uvs) {
+		for (int i = 0; i < p_points; i++) {
+			buffer_data[stride * i + uv_offset + 0] = p_uvs[i].x;
+			buffer_data[stride * i + uv_offset + 1] = p_uvs[i].y;
+		}
+	}
+
+	glBindBuffer(GL_ARRAY_BUFFER, data.polygon_buffer);
+#ifndef GLES_OVER_GL
+	// Orphan the buffer to avoid CPU/GPU sync points caused by glBufferSubData
+	glBufferData(GL_ARRAY_BUFFER, data.polygon_buffer_size, NULL, GL_DYNAMIC_DRAW);
+#endif
+	glBufferSubData(GL_ARRAY_BUFFER, 0, p_points * stride * 4 * sizeof(float), buffer_data);
+
+	glVertexAttribPointer(VS::ARRAY_VERTEX, 2, GL_FLOAT, GL_FALSE, stride * sizeof(float), NULL);
+
+	if (p_colors) {
+		glVertexAttribPointer(VS::ARRAY_COLOR, 4, GL_FLOAT, GL_FALSE, stride * sizeof(float), CAST_INT_TO_UCHAR_PTR(color_offset * sizeof(float)));
+		glEnableVertexAttribArray(VS::ARRAY_COLOR);
+	}
+
+	if (p_uvs) {
+		glVertexAttribPointer(VS::ARRAY_TEX_UV, 2, GL_FLOAT, GL_FALSE, stride * sizeof(float), CAST_INT_TO_UCHAR_PTR(uv_offset * sizeof(float)));
+		glEnableVertexAttribArray(VS::ARRAY_TEX_UV);
+	}
+
+	glDrawArrays(prim[p_points], 0, p_points);
+
+	glBindBuffer(GL_ARRAY_BUFFER, 0);
+}
+
+void RasterizerCanvasBaseGLES2::_copy_screen(const Rect2 &p_rect) {
+
+	if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_DIRECT_TO_SCREEN]) {
+		ERR_PRINT_ONCE("Cannot use screen texture copying in render target set to render direct to screen.");
+		return;
+	}
+
+	ERR_FAIL_COND_MSG(storage->frame.current_rt->copy_screen_effect.color == 0, "Can't use screen texture copying in a render target configured without copy buffers.");
+
+	glDisable(GL_BLEND);
+
+	Vector2 wh(storage->frame.current_rt->width, storage->frame.current_rt->height);
+
+	Color copy_section(p_rect.position.x / wh.x, p_rect.position.y / wh.y, p_rect.size.x / wh.x, p_rect.size.y / wh.y);
+
+	if (p_rect != Rect2()) {
+		storage->shaders.copy.set_conditional(CopyShaderGLES2::USE_COPY_SECTION, true);
+	}
+
+	storage->shaders.copy.set_conditional(CopyShaderGLES2::USE_NO_ALPHA, !state.using_transparent_rt);
+
+	glBindFramebuffer(GL_FRAMEBUFFER, storage->frame.current_rt->copy_screen_effect.fbo);
+	glActiveTexture(GL_TEXTURE0);
+	glBindTexture(GL_TEXTURE_2D, storage->frame.current_rt->color);
+
+	storage->shaders.copy.bind();
+	storage->shaders.copy.set_uniform(CopyShaderGLES2::COPY_SECTION, copy_section);
+
+	const Vector2 vertpos[4] = {
+		Vector2(-1, -1),
+		Vector2(-1, 1),
+		Vector2(1, 1),
+		Vector2(1, -1),
+	};
+
+	const Vector2 uvpos[4] = {
+		Vector2(0, 0),
+		Vector2(0, 1),
+		Vector2(1, 1),
+		Vector2(1, 0)
+	};
+
+	const int indexpos[6] = {
+		0, 1, 2,
+		2, 3, 0
+	};
+
+	_draw_polygon(indexpos, 6, 4, vertpos, uvpos, NULL, false);
+
+	storage->shaders.copy.set_conditional(CopyShaderGLES2::USE_COPY_SECTION, false);
+	storage->shaders.copy.set_conditional(CopyShaderGLES2::USE_NO_ALPHA, false);
+
+	glBindFramebuffer(GL_FRAMEBUFFER, storage->frame.current_rt->fbo); //back to front
+	glEnable(GL_BLEND);
+}
+
+void RasterizerCanvasBaseGLES2::canvas_light_shadow_buffer_update(RID p_buffer, const Transform2D &p_light_xform, int p_light_mask, float p_near, float p_far, LightOccluderInstance *p_occluders, CameraMatrix *p_xform_cache) {
+
+	RasterizerStorageGLES2::CanvasLightShadow *cls = storage->canvas_light_shadow_owner.get(p_buffer);
+	ERR_FAIL_COND(!cls);
+
+	glDisable(GL_BLEND);
+	glDisable(GL_SCISSOR_TEST);
+	glDisable(GL_DITHER);
+	glDisable(GL_CULL_FACE);
+	glDepthFunc(GL_LEQUAL);
+	glEnable(GL_DEPTH_TEST);
+	glDepthMask(true);
+
+	glBindFramebuffer(GL_FRAMEBUFFER, cls->fbo);
+
+	state.canvas_shadow_shader.set_conditional(CanvasShadowShaderGLES2::USE_RGBA_SHADOWS, storage->config.use_rgba_2d_shadows);
+	state.canvas_shadow_shader.bind();
+
+	glViewport(0, 0, cls->size, cls->height);
+	glClearDepth(1.0f);
+	glClearColor(1, 1, 1, 1);
+	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+	VS::CanvasOccluderPolygonCullMode cull = VS::CANVAS_OCCLUDER_POLYGON_CULL_DISABLED;
+
+	for (int i = 0; i < 4; i++) {
+
+		//make sure it remains orthogonal, makes easy to read angle later
+
+		Transform light;
+		light.origin[0] = p_light_xform[2][0];
+		light.origin[1] = p_light_xform[2][1];
+		light.basis[0][0] = p_light_xform[0][0];
+		light.basis[0][1] = p_light_xform[1][0];
+		light.basis[1][0] = p_light_xform[0][1];
+		light.basis[1][1] = p_light_xform[1][1];
+
+		//light.basis.scale(Vector3(to_light.elements[0].length(),to_light.elements[1].length(),1));
+
+		//p_near=1;
+		CameraMatrix projection;
+		{
+			real_t fov = 90;
+			real_t nearp = p_near;
+			real_t farp = p_far;
+			real_t aspect = 1.0;
+
+			real_t ymax = nearp * Math::tan(Math::deg2rad(fov * 0.5));
+			real_t ymin = -ymax;
+			real_t xmin = ymin * aspect;
+			real_t xmax = ymax * aspect;
+
+			projection.set_frustum(xmin, xmax, ymin, ymax, nearp, farp);
+		}
+
+		Vector3 cam_target = Basis(Vector3(0, 0, Math_PI * 2 * (i / 4.0))).xform(Vector3(0, 1, 0));
+		projection = projection * CameraMatrix(Transform().looking_at(cam_target, Vector3(0, 0, -1)).affine_inverse());
+
+		state.canvas_shadow_shader.set_uniform(CanvasShadowShaderGLES2::PROJECTION_MATRIX, projection);
+		state.canvas_shadow_shader.set_uniform(CanvasShadowShaderGLES2::LIGHT_MATRIX, light);
+		state.canvas_shadow_shader.set_uniform(CanvasShadowShaderGLES2::DISTANCE_NORM, 1.0 / p_far);
+
+		if (i == 0)
+			*p_xform_cache = projection;
+
+		glViewport(0, (cls->height / 4) * i, cls->size, cls->height / 4);
+
+		LightOccluderInstance *instance = p_occluders;
+
+		while (instance) {
+
+			RasterizerStorageGLES2::CanvasOccluder *cc = storage->canvas_occluder_owner.getornull(instance->polygon_buffer);
+			if (!cc || cc->len == 0 || !(p_light_mask & instance->light_mask)) {
+
+				instance = instance->next;
+				continue;
+			}
+
+			state.canvas_shadow_shader.set_uniform(CanvasShadowShaderGLES2::WORLD_MATRIX, instance->xform_cache);
+
+			VS::CanvasOccluderPolygonCullMode transformed_cull_cache = instance->cull_cache;
+
+			if (transformed_cull_cache != VS::CANVAS_OCCLUDER_POLYGON_CULL_DISABLED &&
+					(p_light_xform.basis_determinant() * instance->xform_cache.basis_determinant()) < 0) {
+				transformed_cull_cache =
+						transformed_cull_cache == VS::CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE ?
+								VS::CANVAS_OCCLUDER_POLYGON_CULL_COUNTER_CLOCKWISE :
+								VS::CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE;
+			}
+
+			if (cull != transformed_cull_cache) {
+
+				cull = transformed_cull_cache;
+				switch (cull) {
+					case VS::CANVAS_OCCLUDER_POLYGON_CULL_DISABLED: {
+
+						glDisable(GL_CULL_FACE);
+
+					} break;
+					case VS::CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE: {
+
+						glEnable(GL_CULL_FACE);
+						glCullFace(GL_FRONT);
+					} break;
+					case VS::CANVAS_OCCLUDER_POLYGON_CULL_COUNTER_CLOCKWISE: {
+
+						glEnable(GL_CULL_FACE);
+						glCullFace(GL_BACK);
+
+					} break;
+				}
+			}
+
+			glBindBuffer(GL_ARRAY_BUFFER, cc->vertex_id);
+			glEnableVertexAttribArray(VS::ARRAY_VERTEX);
+			glVertexAttribPointer(VS::ARRAY_VERTEX, 3, GL_FLOAT, false, 0, 0);
+			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, cc->index_id);
+
+			glDrawElements(GL_TRIANGLES, cc->len * 3, GL_UNSIGNED_SHORT, 0);
+
+			instance = instance->next;
+		}
+	}
+
+	glBindBuffer(GL_ARRAY_BUFFER, 0);
+	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+}
+
+void RasterizerCanvasBaseGLES2::draw_lens_distortion_rect(const Rect2 &p_rect, float p_k1, float p_k2, const Vector2 &p_eye_center, float p_oversample) {
+	Vector2 half_size;
+	if (storage->frame.current_rt) {
+		half_size = Vector2(storage->frame.current_rt->width, storage->frame.current_rt->height);
+	} else {
+		half_size = OS::get_singleton()->get_window_size();
+	}
+	half_size *= 0.5;
+	Vector2 offset((p_rect.position.x - half_size.x) / half_size.x, (p_rect.position.y - half_size.y) / half_size.y);
+	Vector2 scale(p_rect.size.x / half_size.x, p_rect.size.y / half_size.y);
+
+	float aspect_ratio = p_rect.size.x / p_rect.size.y;
+
+	// setup our lens shader
+	state.lens_shader.bind();
+	state.lens_shader.set_uniform(LensDistortedShaderGLES2::OFFSET, offset);
+	state.lens_shader.set_uniform(LensDistortedShaderGLES2::SCALE, scale);
+	state.lens_shader.set_uniform(LensDistortedShaderGLES2::K1, p_k1);
+	state.lens_shader.set_uniform(LensDistortedShaderGLES2::K2, p_k2);
+	state.lens_shader.set_uniform(LensDistortedShaderGLES2::EYE_CENTER, p_eye_center);
+	state.lens_shader.set_uniform(LensDistortedShaderGLES2::UPSCALE, p_oversample);
+	state.lens_shader.set_uniform(LensDistortedShaderGLES2::ASPECT_RATIO, aspect_ratio);
+
+	// bind our quad buffer
+	_bind_quad_buffer();
+
+	// and draw
+	glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+
+	// and cleanup
+	glBindBuffer(GL_ARRAY_BUFFER, 0);
+
+	for (int i = 0; i < VS::ARRAY_MAX; i++) {
+		glDisableVertexAttribArray(i);
+	}
+}
+
+void RasterizerCanvasBaseGLES2::initialize() {
+
+	// quad buffer
+	{
+		glGenBuffers(1, &data.canvas_quad_vertices);
+		glBindBuffer(GL_ARRAY_BUFFER, data.canvas_quad_vertices);
+
+		const float qv[8] = {
+			0, 0,
+			0, 1,
+			1, 1,
+			1, 0
+		};
+
+		glBufferData(GL_ARRAY_BUFFER, sizeof(float) * 8, qv, GL_STATIC_DRAW);
+
+		glBindBuffer(GL_ARRAY_BUFFER, 0);
+	}
+
+	// polygon buffer
+	{
+		uint32_t poly_size = GLOBAL_DEF("rendering/limits/buffers/canvas_polygon_buffer_size_kb", 128);
+		ProjectSettings::get_singleton()->set_custom_property_info("rendering/limits/buffers/canvas_polygon_buffer_size_kb", PropertyInfo(Variant::INT, "rendering/limits/buffers/canvas_polygon_buffer_size_kb", PROPERTY_HINT_RANGE, "0,256,1,or_greater"));
+		poly_size *= 1024;
+		poly_size = MAX(poly_size, (2 + 2 + 4) * 4 * sizeof(float));
+		glGenBuffers(1, &data.polygon_buffer);
+		glBindBuffer(GL_ARRAY_BUFFER, data.polygon_buffer);
+		glBufferData(GL_ARRAY_BUFFER, poly_size, NULL, GL_DYNAMIC_DRAW);
+
+		data.polygon_buffer_size = poly_size;
+
+		glBindBuffer(GL_ARRAY_BUFFER, 0);
+
+		uint32_t index_size = GLOBAL_DEF("rendering/limits/buffers/canvas_polygon_index_buffer_size_kb", 128);
+		ProjectSettings::get_singleton()->set_custom_property_info("rendering/limits/buffers/canvas_polygon_index_buffer_size_kb", PropertyInfo(Variant::INT, "rendering/limits/buffers/canvas_polygon_index_buffer_size_kb", PROPERTY_HINT_RANGE, "0,256,1,or_greater"));
+		index_size *= 1024; // kb
+		glGenBuffers(1, &data.polygon_index_buffer);
+		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, data.polygon_index_buffer);
+		glBufferData(GL_ELEMENT_ARRAY_BUFFER, index_size, NULL, GL_DYNAMIC_DRAW);
+		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+
+		data.polygon_index_buffer_size = index_size;
+	}
+
+	// ninepatch buffers
+	{
+		// array buffer
+		glGenBuffers(1, &data.ninepatch_vertices);
+		glBindBuffer(GL_ARRAY_BUFFER, data.ninepatch_vertices);
+
+		glBufferData(GL_ARRAY_BUFFER, sizeof(float) * (16 + 16) * 2, NULL, GL_DYNAMIC_DRAW);
+
+		glBindBuffer(GL_ARRAY_BUFFER, 0);
+
+		// element buffer
+		glGenBuffers(1, &data.ninepatch_elements);
+		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, data.ninepatch_elements);
+
+#define _EIDX(y, x) (y * 4 + x)
+		uint8_t elems[3 * 2 * 9] = {
+
+			// first row
+
+			_EIDX(0, 0), _EIDX(0, 1), _EIDX(1, 1),
+			_EIDX(1, 1), _EIDX(1, 0), _EIDX(0, 0),
+
+			_EIDX(0, 1), _EIDX(0, 2), _EIDX(1, 2),
+			_EIDX(1, 2), _EIDX(1, 1), _EIDX(0, 1),
+
+			_EIDX(0, 2), _EIDX(0, 3), _EIDX(1, 3),
+			_EIDX(1, 3), _EIDX(1, 2), _EIDX(0, 2),
+
+			// second row
+
+			_EIDX(1, 0), _EIDX(1, 1), _EIDX(2, 1),
+			_EIDX(2, 1), _EIDX(2, 0), _EIDX(1, 0),
+
+			// the center one would be here, but we'll put it at the end
+			// so it's easier to disable the center and be able to use
+			// one draw call for both
+
+			_EIDX(1, 2), _EIDX(1, 3), _EIDX(2, 3),
+			_EIDX(2, 3), _EIDX(2, 2), _EIDX(1, 2),
+
+			// third row
+
+			_EIDX(2, 0), _EIDX(2, 1), _EIDX(3, 1),
+			_EIDX(3, 1), _EIDX(3, 0), _EIDX(2, 0),
+
+			_EIDX(2, 1), _EIDX(2, 2), _EIDX(3, 2),
+			_EIDX(3, 2), _EIDX(3, 1), _EIDX(2, 1),
+
+			_EIDX(2, 2), _EIDX(2, 3), _EIDX(3, 3),
+			_EIDX(3, 3), _EIDX(3, 2), _EIDX(2, 2),
+
+			// center field
+
+			_EIDX(1, 1), _EIDX(1, 2), _EIDX(2, 2),
+			_EIDX(2, 2), _EIDX(2, 1), _EIDX(1, 1)
+		};
+#undef _EIDX
+
+		glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(elems), elems, GL_STATIC_DRAW);
+
+		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+	}
+
+	state.canvas_shadow_shader.init();
+
+	state.canvas_shader.init();
+
+	state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, true);
+	state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_RGBA_SHADOWS, storage->config.use_rgba_2d_shadows);
+
+	state.canvas_shader.bind();
+
+	state.lens_shader.init();
+
+	state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_PIXEL_SNAP, GLOBAL_DEF("rendering/quality/2d/use_pixel_snap", false));
+
+	state.using_light = NULL;
+	state.using_transparent_rt = false;
+	state.using_skeleton = false;
+}
+
+void RasterizerCanvasBaseGLES2::finalize() {
+}
+
+RasterizerCanvasBaseGLES2::RasterizerCanvasBaseGLES2() {
+#ifdef GLES_OVER_GL
+	use_nvidia_rect_workaround = GLOBAL_GET("rendering/quality/2d/gles2_use_nvidia_rect_flicker_workaround");
+#else
+	// Not needed (a priori) on GLES devices
+	use_nvidia_rect_workaround = false;
+#endif
+}
diff --git a/drivers/gles2/rasterizer_canvas_base_gles2.h b/drivers/gles2/rasterizer_canvas_base_gles2.h
new file mode 100644
index 00000000000..8fda4f3d8f1
--- /dev/null
+++ b/drivers/gles2/rasterizer_canvas_base_gles2.h
@@ -0,0 +1,140 @@
+/*************************************************************************/
+/*  rasterizer_canvas_base_gles2.h                                       */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                      https://godotengine.org                          */
+/*************************************************************************/
+/* Copyright (c) 2007-2020 Juan Linietsky, Ariel Manzur.                 */
+/* Copyright (c) 2014-2020 Godot Engine contributors (cf. AUTHORS.md).   */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+
+#ifndef RASTERIZERCANVASBASEGLES2_H
+#define RASTERIZERCANVASBASEGLES2_H
+
+#include "rasterizer_array.h"
+#include "rasterizer_storage_gles2.h"
+#include "servers/visual/rasterizer.h"
+
+#include "shaders/canvas.glsl.gen.h"
+#include "shaders/lens_distorted.glsl.gen.h"
+
+#include "shaders/canvas_shadow.glsl.gen.h"
+
+class RasterizerCanvasBaseGLES2 : public RasterizerCanvas {
+public:
+	enum {
+		INSTANCE_ATTRIB_BASE = 8,
+	};
+
+	struct Uniforms {
+		Transform projection_matrix;
+
+		Transform2D modelview_matrix;
+		Transform2D extra_matrix;
+
+		Color final_modulate;
+
+		float time;
+	};
+
+	struct Data {
+		GLuint canvas_quad_vertices;
+		GLuint polygon_buffer;
+		GLuint polygon_index_buffer;
+
+		uint32_t polygon_buffer_size;
+		uint32_t polygon_index_buffer_size;
+
+		GLuint ninepatch_vertices;
+		GLuint ninepatch_elements;
+	} data;
+
+	struct State {
+		Uniforms uniforms;
+		bool canvas_texscreen_used;
+		CanvasShaderGLES2 canvas_shader;
+		CanvasShadowShaderGLES2 canvas_shadow_shader;
+		LensDistortedShaderGLES2 lens_shader;
+
+		bool using_texture_rect;
+		bool using_ninepatch;
+		bool using_skeleton;
+
+		Transform2D skeleton_transform;
+		Transform2D skeleton_transform_inverse;
+		Size2i skeleton_texture_size;
+
+		RID current_tex;
+		RID current_normal;
+		RasterizerStorageGLES2::Texture *current_tex_ptr;
+
+		Transform vp;
+		Light *using_light;
+		bool using_shadow;
+		bool using_transparent_rt;
+
+	} state;
+
+	typedef void Texture;
+
+	RasterizerSceneGLES2 *scene_render;
+
+	RasterizerStorageGLES2 *storage;
+
+	bool use_nvidia_rect_workaround;
+
+	void _set_uniforms();
+
+	virtual RID light_internal_create();
+	virtual void light_internal_update(RID p_rid, Light *p_light);
+	virtual void light_internal_free(RID p_rid);
+
+	virtual void canvas_begin();
+	virtual void canvas_end();
+
+	void _draw_gui_primitive(int p_points, const Vector2 *p_vertices, const Color *p_colors, const Vector2 *p_uvs);
+	void _draw_polygon(const int *p_indices, int p_index_count, int p_vertex_count, const Vector2 *p_vertices, const Vector2 *p_uvs, const Color *p_colors, bool p_singlecolor, const float *p_weights = NULL, const int *p_bones = NULL);
+	void _draw_generic(GLuint p_primitive, int p_vertex_count, const Vector2 *p_vertices, const Vector2 *p_uvs, const Color *p_colors, bool p_singlecolor);
+	void _draw_generic_indices(GLuint p_primitive, const int *p_indices, int p_index_count, int p_vertex_count, const Vector2 *p_vertices, const Vector2 *p_uvs, const Color *p_colors, bool p_singlecolor);
+
+	void _bind_quad_buffer();
+	void _copy_texscreen(const Rect2 &p_rect);
+	void _copy_screen(const Rect2 &p_rect);
+
+	virtual void draw_window_margins(int *black_margin, RID *black_image);
+	void draw_generic_textured_rect(const Rect2 &p_rect, const Rect2 &p_src);
+	void draw_lens_distortion_rect(const Rect2 &p_rect, float p_k1, float p_k2, const Vector2 &p_eye_center, float p_oversample);
+
+	virtual void reset_canvas();
+	virtual void canvas_light_shadow_buffer_update(RID p_buffer, const Transform2D &p_light_xform, int p_light_mask, float p_near, float p_far, LightOccluderInstance *p_occluders, CameraMatrix *p_xform_cache);
+	virtual void canvas_debug_viewport_shadows(Light *p_lights_with_shadow);
+
+	RasterizerStorageGLES2::Texture *_bind_canvas_texture(const RID &p_texture, const RID &p_normal_map);
+
+	void initialize();
+	void finalize();
+
+	RasterizerCanvasBaseGLES2();
+};
+
+#endif // RASTERIZERCANVASBASEGLES2_H
diff --git a/drivers/gles2/rasterizer_canvas_gles2.cpp b/drivers/gles2/rasterizer_canvas_gles2.cpp
index 373d3989ce4..19e0e9944ef 100644
--- a/drivers/gles2/rasterizer_canvas_gles2.cpp
+++ b/drivers/gles2/rasterizer_canvas_gles2.cpp
@@ -35,1403 +35,1532 @@
 #include "rasterizer_scene_gles2.h"
 #include "servers/visual/visual_server_raster.h"
 
-#ifndef GLES_OVER_GL
-#define glClearDepth glClearDepthf
-#endif
-
-RID RasterizerCanvasGLES2::light_internal_create() {
+// For debugging, if this is defined, it will flash on alternate frames
+// between the non-batched renderer and the batched renderer,
+// in order to find regressions.
+// This should not be defined except during development.
+//#define KESSEL_FLASH
 
-	return RID();
-}
+static const GLenum gl_primitive[] = {
+	GL_POINTS,
+	GL_LINES,
+	GL_LINE_STRIP,
+	GL_LINE_LOOP,
+	GL_TRIANGLES,
+	GL_TRIANGLE_STRIP,
+	GL_TRIANGLE_FAN
+};
 
-void RasterizerCanvasGLES2::light_internal_update(RID p_rid, Light *p_light) {
-}
+RasterizerStorageGLES2::Texture *RasterizerCanvasGLES2::_get_canvas_texture(const RID &p_texture) const {
+	if (p_texture.is_valid()) {
 
-void RasterizerCanvasGLES2::light_internal_free(RID p_rid) {
-}
+		RasterizerStorageGLES2::Texture *texture = storage->texture_owner.getornull(p_texture);
 
-void RasterizerCanvasGLES2::_set_uniforms() {
+		if (texture) {
+			return texture->get_ptr();
+		}
+	}
 
-	state.canvas_shader.set_uniform(CanvasShaderGLES2::PROJECTION_MATRIX, state.uniforms.projection_matrix);
-	state.canvas_shader.set_uniform(CanvasShaderGLES2::MODELVIEW_MATRIX, state.uniforms.modelview_matrix);
-	state.canvas_shader.set_uniform(CanvasShaderGLES2::EXTRA_MATRIX, state.uniforms.extra_matrix);
+	return 0;
+}
 
-	state.canvas_shader.set_uniform(CanvasShaderGLES2::FINAL_MODULATE, state.uniforms.final_modulate);
+int RasterizerCanvasGLES2::_batch_find_or_create_tex(const RID &p_texture, const RID &p_normal, bool p_tile, int p_previous_match) {
 
-	state.canvas_shader.set_uniform(CanvasShaderGLES2::TIME, storage->frame.time[0]);
+	// optimization .. in 99% cases the last matched value will be the same, so no need to traverse the list
+	if (p_previous_match > 0) // if it is zero, it will get hit first in the linear search anyway
+	{
+		const BatchTex &batch_texture = bdata.batch_textures[p_previous_match];
 
-	if (storage->frame.current_rt) {
-		Vector2 screen_pixel_size;
-		screen_pixel_size.x = 1.0 / storage->frame.current_rt->width;
-		screen_pixel_size.y = 1.0 / storage->frame.current_rt->height;
+		// note for future reference, if RID implementation changes, this could become more expensive
+		if ((batch_texture.RID_texture == p_texture) && (batch_texture.RID_normal == p_normal)) {
+			// tiling mode must also match
+			bool tiles = batch_texture.tile_mode != BatchTex::TILE_OFF;
 
-		state.canvas_shader.set_uniform(CanvasShaderGLES2::SCREEN_PIXEL_SIZE, screen_pixel_size);
+			if (tiles == p_tile)
+				// match!
+				return p_previous_match;
+		}
 	}
 
-	if (state.using_skeleton) {
-		state.canvas_shader.set_uniform(CanvasShaderGLES2::SKELETON_TRANSFORM, state.skeleton_transform);
-		state.canvas_shader.set_uniform(CanvasShaderGLES2::SKELETON_TRANSFORM_INVERSE, state.skeleton_transform_inverse);
-		state.canvas_shader.set_uniform(CanvasShaderGLES2::SKELETON_TEXTURE_SIZE, state.skeleton_texture_size);
-	}
+	// not the previous match .. we will do a linear search ... slower, but should happen
+	// not very often except with non-batchable runs, which are going to be slow anyway
+	// n.b. could possibly be replaced later by a fast hash table
+	for (int n = 0; n < bdata.batch_textures.size(); n++) {
+		const BatchTex &batch_texture = bdata.batch_textures[n];
+		if ((batch_texture.RID_texture == p_texture) && (batch_texture.RID_normal == p_normal)) {
 
-	if (state.using_light) {
-
-		Light *light = state.using_light;
-		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_MATRIX, light->light_shader_xform);
-		Transform2D basis_inverse = light->light_shader_xform.affine_inverse().orthonormalized();
-		basis_inverse[2] = Vector2();
-		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_MATRIX_INVERSE, basis_inverse);
-		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_LOCAL_MATRIX, light->xform_cache.affine_inverse());
-		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_COLOR, light->color * light->energy);
-		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_POS, light->light_shader_pos);
-		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_HEIGHT, light->height);
-		state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_OUTSIDE_ALPHA, light->mode == VS::CANVAS_LIGHT_MODE_MASK ? 1.0 : 0.0);
-
-		if (state.using_shadow) {
-			RasterizerStorageGLES2::CanvasLightShadow *cls = storage->canvas_light_shadow_owner.get(light->shadow_buffer);
-			glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 5);
-			glBindTexture(GL_TEXTURE_2D, cls->distance);
-			state.canvas_shader.set_uniform(CanvasShaderGLES2::SHADOW_MATRIX, light->shadow_matrix_cache);
-			state.canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_SHADOW_COLOR, light->shadow_color);
-
-			state.canvas_shader.set_uniform(CanvasShaderGLES2::SHADOWPIXEL_SIZE, (1.0 / light->shadow_buffer_size) * (1.0 + light->shadow_smooth));
-			if (light->radius_cache == 0) {
-				state.canvas_shader.set_uniform(CanvasShaderGLES2::SHADOW_GRADIENT, 0.0);
-			} else {
-				state.canvas_shader.set_uniform(CanvasShaderGLES2::SHADOW_GRADIENT, light->shadow_gradient_length / (light->radius_cache * 1.1));
-			}
-			state.canvas_shader.set_uniform(CanvasShaderGLES2::SHADOW_DISTANCE_MULT, light->radius_cache * 1.1);
+			// tiling mode must also match
+			bool tiles = batch_texture.tile_mode != BatchTex::TILE_OFF;
 
-			/*canvas_shader.set_uniform(CanvasShaderGLES2::SHADOW_MATRIX,light->shadow_matrix_cache);
-			canvas_shader.set_uniform(CanvasShaderGLES2::SHADOW_ESM_MULTIPLIER,light->shadow_esm_mult);
-			canvas_shader.set_uniform(CanvasShaderGLES2::LIGHT_SHADOW_COLOR,light->shadow_color);*/
+			if (tiles == p_tile)
+				// match!
+				return n;
 		}
 	}
-}
-
-void RasterizerCanvasGLES2::canvas_begin() {
 
-	state.canvas_shader.bind();
-	state.using_transparent_rt = false;
-	int viewport_x, viewport_y, viewport_width, viewport_height;
+	// pushing back from local variable .. not ideal but has to use a Vector because non pod
+	// due to RIDs
+	BatchTex b;
+	b.RID_texture = p_texture;
+	b.RID_normal = p_normal;
 
-	if (storage->frame.current_rt) {
-		glBindFramebuffer(GL_FRAMEBUFFER, storage->frame.current_rt->fbo);
-		state.using_transparent_rt = storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT];
+	// get the texture
+	RasterizerStorageGLES2::Texture *texture = _get_canvas_texture(p_texture);
 
-		if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_DIRECT_TO_SCREEN]) {
-			// set Viewport and Scissor when rendering directly to screen
-			viewport_width = storage->frame.current_rt->width;
-			viewport_height = storage->frame.current_rt->height;
-			viewport_x = storage->frame.current_rt->x;
-			viewport_y = OS::get_singleton()->get_window_size().height - viewport_height - storage->frame.current_rt->y;
-			glScissor(viewport_x, viewport_y, viewport_width, viewport_height);
-			glViewport(viewport_x, viewport_y, viewport_width, viewport_height);
-			glEnable(GL_SCISSOR_TEST);
-		}
+	if (texture) {
+		b.tex_pixel_size.x = 1.0 / texture->width;
+		b.tex_pixel_size.y = 1.0 / texture->height;
+	} else {
+		// maybe doesn't need doing...
+		b.tex_pixel_size.x = 1.0;
+		b.tex_pixel_size.y = 1.0;
 	}
 
-	if (storage->frame.clear_request) {
-		glClearColor(storage->frame.clear_request_color.r,
-				storage->frame.clear_request_color.g,
-				storage->frame.clear_request_color.b,
-				state.using_transparent_rt ? storage->frame.clear_request_color.a : 1.0);
-		glClear(GL_COLOR_BUFFER_BIT);
-		storage->frame.clear_request = false;
-	}
+	if (p_tile) {
+		if (texture) {
+			// default
+			b.tile_mode = BatchTex::TILE_NORMAL;
 
-	/*
-	if (storage->frame.current_rt) {
-		glBindFramebuffer(GL_FRAMEBUFFER, storage->frame.current_rt->fbo);
-		glColorMask(1, 1, 1, 1);
+			// no hardware support for non power of 2 tiling
+			if (!storage->config.support_npot_repeat_mipmap) {
+				if (next_power_of_2(texture->alloc_width) != (unsigned int)texture->alloc_width && next_power_of_2(texture->alloc_height) != (unsigned int)texture->alloc_height) {
+					b.tile_mode = BatchTex::TILE_FORCE_REPEAT;
+				}
+			}
+		} else {
+			// this should not happen?
+			b.tile_mode = BatchTex::TILE_OFF;
+		}
+	} else {
+		b.tile_mode = BatchTex::TILE_OFF;
 	}
-	*/
 
-	reset_canvas();
+	// push back
+	bdata.batch_textures.push_back(b);
 
-	glActiveTexture(GL_TEXTURE0);
-	glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
+	return bdata.batch_textures.size() - 1;
+}
 
-	glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
-	glDisableVertexAttribArray(VS::ARRAY_COLOR);
+void RasterizerCanvasGLES2::_batch_upload_buffers() {
 
-	// set up default uniforms
+	// noop?
+	if (!bdata.vertices.size())
+		return;
 
-	Transform canvas_transform;
+	glBindBuffer(GL_ARRAY_BUFFER, bdata.gl_vertex_buffer);
 
-	if (storage->frame.current_rt) {
+	// orphan the old (for now)
+	glBufferData(GL_ARRAY_BUFFER, 0, 0, GL_DYNAMIC_DRAW);
 
-		float csy = 1.0;
-		if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_VFLIP]) {
-			csy = -1.0;
-		}
-		canvas_transform.translate(-(storage->frame.current_rt->width / 2.0f), -(storage->frame.current_rt->height / 2.0f), 0.0f);
-		canvas_transform.scale(Vector3(2.0f / storage->frame.current_rt->width, csy * -2.0f / storage->frame.current_rt->height, 1.0f));
+	if (!bdata.use_colored_vertices) {
+		glBufferData(GL_ARRAY_BUFFER, sizeof(BatchVertex) * bdata.vertices.size(), bdata.vertices.get_data(), GL_DYNAMIC_DRAW);
 	} else {
-		Vector2 ssize = OS::get_singleton()->get_window_size();
-		canvas_transform.translate(-(ssize.width / 2.0f), -(ssize.height / 2.0f), 0.0f);
-		canvas_transform.scale(Vector3(2.0f / ssize.width, -2.0f / ssize.height, 1.0f));
+		glBufferData(GL_ARRAY_BUFFER, sizeof(BatchVertexColored) * bdata.vertices_colored.size(), bdata.vertices_colored.get_data(), GL_DYNAMIC_DRAW);
 	}
 
-	state.uniforms.projection_matrix = canvas_transform;
-
-	state.uniforms.final_modulate = Color(1, 1, 1, 1);
-
-	state.uniforms.modelview_matrix = Transform2D();
-	state.uniforms.extra_matrix = Transform2D();
-
-	_set_uniforms();
-	_bind_quad_buffer();
+	// might not be necessary
+	glBindBuffer(GL_ARRAY_BUFFER, 0);
 }
 
-void RasterizerCanvasGLES2::canvas_end() {
+RasterizerCanvasGLES2::Batch *RasterizerCanvasGLES2::_batch_request_new(bool p_blank) {
+	Batch *batch = bdata.batches.request();
+	if (!batch) {
+		// grow the batches
+		bdata.batches.grow();
 
-	glBindBuffer(GL_ARRAY_BUFFER, 0);
+		// and the temporary batches (used for color verts)
+		bdata.batches_temp.reset();
+		bdata.batches_temp.grow();
 
-	for (int i = 0; i < VS::ARRAY_MAX; i++) {
-		glDisableVertexAttribArray(i);
+		// this should always succeed after growing
+		batch = bdata.batches.request();
+#ifdef DEBUG_ENABLED
+		CRASH_COND(!batch);
+#endif
 	}
 
-	if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_DIRECT_TO_SCREEN]) {
-		//reset viewport to full window size
-		int viewport_width = OS::get_singleton()->get_window_size().width;
-		int viewport_height = OS::get_singleton()->get_window_size().height;
-		glViewport(0, 0, viewport_width, viewport_height);
-		glScissor(0, 0, viewport_width, viewport_height);
-	}
+	if (p_blank)
+		memset(batch, 0, sizeof(Batch));
 
-	state.using_texture_rect = false;
-	state.using_skeleton = false;
-	state.using_ninepatch = false;
-	state.using_transparent_rt = false;
+	return batch;
 }
 
-RasterizerStorageGLES2::Texture *RasterizerCanvasGLES2::_bind_canvas_texture(const RID &p_texture, const RID &p_normal_map) {
+// This function may be called MULTIPLE TIMES for each item, so needs to record how far it has got
+bool RasterizerCanvasGLES2::prefill_joined_item(FillState &fill_state, int &r_command_start, Item *p_item, Item *current_clip, bool &reclip, RasterizerStorageGLES2::Material *p_material) {
+	// we will prefill batches and vertices ready for sending in one go to the vertex buffer
+	int command_count = p_item->commands.size();
+	Item::Command *const *commands = p_item->commands.ptr();
 
-	RasterizerStorageGLES2::Texture *tex_return = NULL;
+	Transform2D transform;
+	TransformMode transform_mode = _find_transform_mode(fill_state.use_hardware_transform, p_item->final_transform, transform);
 
-	if (p_texture.is_valid()) {
+	Vector2 texpixel_size = fill_state.texpixel_size;
 
-		RasterizerStorageGLES2::Texture *texture = storage->texture_owner.getornull(p_texture);
+	// start batch is a dummy batch (tex id -1) .. could be made more efficient
+	if (!fill_state.curr_batch) {
+		fill_state.curr_batch = _batch_request_new();
+		fill_state.curr_batch->type = Batch::BT_DEFAULT;
+		fill_state.curr_batch->first_command = r_command_start;
+		// should tex_id be set to -1? check this
+	}
 
-		if (!texture) {
-			state.current_tex = RID();
-			state.current_tex_ptr = NULL;
+	// we need to return which command we got up to, so
+	// store this outside the loop
+	int command_num;
 
-			glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 1);
-			glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
+	//print_line("_batch_canvas_joined_item_prefill : from " + itos(r_command_start) + " to " + itos(command_count));
 
-		} else {
+	// do as many commands as possible until the vertex buffer will be full up
+	for (command_num = r_command_start; command_num < command_count; command_num++) {
 
-			if (texture->redraw_if_visible) {
-				VisualServerRaster::redraw_request();
-			}
+		Item::Command *command = commands[command_num];
 
-			texture = texture->get_ptr();
+		switch (command->type) {
 
-			if (texture->render_target) {
-				texture->render_target->used_in_frame = true;
-			}
+			default: {
+				if (fill_state.curr_batch->type == Batch::BT_DEFAULT) {
+					// another default command, just add to the existing batch
+					fill_state.curr_batch->num_commands++;
+				} else {
+					// end of previous different type batch, so start new default batch
+					fill_state.curr_batch = _batch_request_new();
+					fill_state.curr_batch->type = Batch::BT_DEFAULT;
+					fill_state.curr_batch->first_command = command_num;
+					fill_state.curr_batch->num_commands = 1;
+				}
+			} break;
+			case Item::Command::TYPE_RECT: {
 
-			glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 1);
-			glBindTexture(GL_TEXTURE_2D, texture->tex_id);
+				Item::CommandRect *rect = static_cast<Item::CommandRect *>(command);
 
-			state.current_tex = p_texture;
-			state.current_tex_ptr = texture;
+				const Color &col = rect->modulate;
 
-			tex_return = texture;
-		}
-	} else {
-		state.current_tex = RID();
-		state.current_tex_ptr = NULL;
+				// instead of doing all the texture preparation for EVERY rect,
+				// we build a list of texture combinations and do this once off.
+				// This means we have a potentially rather slow step to identify which texture combo
+				// using the RIDs.
+				int old_bti = fill_state.batch_tex_id;
+				fill_state.batch_tex_id = _batch_find_or_create_tex(rect->texture, rect->normal_map, rect->flags & CANVAS_RECT_TILE, old_bti);
 
-		glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 1);
-		glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
-	}
+				// try to create vertices BEFORE creating a batch,
+				// because if the vertex buffer is full, we need to finish this
+				// function, draw what we have so far, and then start a new set of batches
 
-	if (p_normal_map == state.current_normal) {
-		//do none
-		state.canvas_shader.set_uniform(CanvasShaderGLES2::USE_DEFAULT_NORMAL, state.current_normal.is_valid());
+				// request FOUR vertices at a time, this is more efficient
+				BatchVertex *bvs = bdata.vertices.request_four();
+				if (!bvs) {
+					// run out of space in the vertex buffer .. finish this function and draw what we have so far
+					// return where we got to
+					r_command_start = command_num;
+					return true;
+				}
 
-	} else if (p_normal_map.is_valid()) {
+				bool change_batch = false;
 
-		RasterizerStorageGLES2::Texture *normal_map = storage->texture_owner.getornull(p_normal_map);
+				// conditions for creating a new batch
+				if ((fill_state.curr_batch->type != Batch::BT_RECT) || (old_bti != fill_state.batch_tex_id)) {
+					change_batch = true;
+				}
 
-		if (!normal_map) {
-			state.current_normal = RID();
-			glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 2);
-			glBindTexture(GL_TEXTURE_2D, storage->resources.normal_tex);
-			state.canvas_shader.set_uniform(CanvasShaderGLES2::USE_DEFAULT_NORMAL, false);
+				// we need to treat color change separately because we need to count these
+				// to decide whether to switch on the fly to colored vertices.
+				if (!fill_state.curr_batch->color.equals(col)) {
+					change_batch = true;
+					bdata.total_color_changes++;
+				}
 
-		} else {
+				if (change_batch) {
+					// put the tex pixel size  in a local (less verbose and can be a register)
+					bdata.batch_textures[fill_state.batch_tex_id].tex_pixel_size.to(texpixel_size);
 
-			if (normal_map->redraw_if_visible) { //check before proxy, because this is usually used with proxies
-				VisualServerRaster::redraw_request();
-			}
+					// need to preserve texpixel_size between items
+					fill_state.texpixel_size = texpixel_size;
 
-			normal_map = normal_map->get_ptr();
+					// open new batch (this should never fail, it dynamically grows)
+					fill_state.curr_batch = _batch_request_new(false);
 
-			glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 2);
-			glBindTexture(GL_TEXTURE_2D, normal_map->tex_id);
-			state.current_normal = p_normal_map;
-			state.canvas_shader.set_uniform(CanvasShaderGLES2::USE_DEFAULT_NORMAL, true);
-		}
+					fill_state.curr_batch->type = Batch::BT_RECT;
+					fill_state.curr_batch->color.set(col);
+					fill_state.curr_batch->batch_texture_id = fill_state.batch_tex_id;
+					fill_state.curr_batch->first_command = command_num;
+					fill_state.curr_batch->num_commands = 1;
+					fill_state.curr_batch->first_quad = bdata.total_quads;
+				} else {
+					// we could alternatively do the count when closing a batch .. perhaps more efficient
+					fill_state.curr_batch->num_commands++;
+				}
 
-	} else {
+				// fill the quad geometry
+				Vector2 mins = rect->rect.position;
 
-		state.current_normal = RID();
-		glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 2);
-		glBindTexture(GL_TEXTURE_2D, storage->resources.normal_tex);
-		state.canvas_shader.set_uniform(CanvasShaderGLES2::USE_DEFAULT_NORMAL, false);
-	}
+				if (transform_mode == TM_TRANSLATE) {
+					_software_transform_vertex(mins, transform);
+				}
 
-	return tex_return;
-}
+				Vector2 maxs = mins + rect->rect.size;
 
-void RasterizerCanvasGLES2::_draw_polygon(const int *p_indices, int p_index_count, int p_vertex_count, const Vector2 *p_vertices, const Vector2 *p_uvs, const Color *p_colors, bool p_singlecolor, const float *p_weights, const int *p_bones) {
+				// just aliases
+				BatchVertex *bA = &bvs[0];
+				BatchVertex *bB = &bvs[1];
+				BatchVertex *bC = &bvs[2];
+				BatchVertex *bD = &bvs[3];
 
-	glBindBuffer(GL_ARRAY_BUFFER, data.polygon_buffer);
-#ifndef GLES_OVER_GL
-	// Orphan the buffer to avoid CPU/GPU sync points caused by glBufferSubData
-	glBufferData(GL_ARRAY_BUFFER, data.polygon_buffer_size, NULL, GL_DYNAMIC_DRAW);
-#endif
+				bA->pos.x = mins.x;
+				bA->pos.y = mins.y;
 
-	uint32_t buffer_ofs = 0;
+				bB->pos.x = maxs.x;
+				bB->pos.y = mins.y;
 
-	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(Vector2) * p_vertex_count, p_vertices);
-	glEnableVertexAttribArray(VS::ARRAY_VERTEX);
-	glVertexAttribPointer(VS::ARRAY_VERTEX, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2), NULL);
-	buffer_ofs += sizeof(Vector2) * p_vertex_count;
+				bC->pos.x = maxs.x;
+				bC->pos.y = maxs.y;
 
-	if (p_singlecolor) {
-		glDisableVertexAttribArray(VS::ARRAY_COLOR);
-		Color m = *p_colors;
-		glVertexAttrib4f(VS::ARRAY_COLOR, m.r, m.g, m.b, m.a);
-	} else if (!p_colors) {
-		glDisableVertexAttribArray(VS::ARRAY_COLOR);
-		glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
-	} else {
-		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(Color) * p_vertex_count, p_colors);
-		glEnableVertexAttribArray(VS::ARRAY_COLOR);
-		glVertexAttribPointer(VS::ARRAY_COLOR, 4, GL_FLOAT, GL_FALSE, sizeof(Color), CAST_INT_TO_UCHAR_PTR(buffer_ofs));
-		buffer_ofs += sizeof(Color) * p_vertex_count;
-	}
+				bD->pos.x = mins.x;
+				bD->pos.y = maxs.y;
 
-	if (p_uvs) {
-		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(Vector2) * p_vertex_count, p_uvs);
-		glEnableVertexAttribArray(VS::ARRAY_TEX_UV);
-		glVertexAttribPointer(VS::ARRAY_TEX_UV, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2), CAST_INT_TO_UCHAR_PTR(buffer_ofs));
-		buffer_ofs += sizeof(Vector2) * p_vertex_count;
-	} else {
-		glDisableVertexAttribArray(VS::ARRAY_TEX_UV);
-	}
+				if (rect->rect.size.x < 0) {
+					SWAP(bA->pos, bB->pos);
+					SWAP(bC->pos, bD->pos);
+				}
+				if (rect->rect.size.y < 0) {
+					SWAP(bA->pos, bD->pos);
+					SWAP(bB->pos, bC->pos);
+				}
 
-	if (p_weights && p_bones) {
-		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(float) * 4 * p_vertex_count, p_weights);
-		glEnableVertexAttribArray(VS::ARRAY_WEIGHTS);
-		glVertexAttribPointer(VS::ARRAY_WEIGHTS, 4, GL_FLOAT, GL_FALSE, sizeof(float) * 4, CAST_INT_TO_UCHAR_PTR(buffer_ofs));
-		buffer_ofs += sizeof(float) * 4 * p_vertex_count;
+				if (transform_mode == TM_ALL) {
+					_software_transform_vertex(bA->pos, transform);
+					_software_transform_vertex(bB->pos, transform);
+					_software_transform_vertex(bC->pos, transform);
+					_software_transform_vertex(bD->pos, transform);
+				}
 
-		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(int) * 4 * p_vertex_count, p_bones);
-		glEnableVertexAttribArray(VS::ARRAY_BONES);
-		glVertexAttribPointer(VS::ARRAY_BONES, 4, GL_UNSIGNED_INT, GL_FALSE, sizeof(int) * 4, CAST_INT_TO_UCHAR_PTR(buffer_ofs));
-		buffer_ofs += sizeof(int) * 4 * p_vertex_count;
+				// uvs
+				Rect2 src_rect = (rect->flags & CANVAS_RECT_REGION) ? Rect2(rect->source.position * texpixel_size, rect->source.size * texpixel_size) : Rect2(0, 0, 1, 1);
+				//				Rect2 src_rect = Rect2(0, 0, 1, 1);
+
+				// 10% faster calculating the max first
+				Vector2 pos_max = src_rect.position + src_rect.size;
+				Vector2 uvs[4] = {
+					src_rect.position,
+					Vector2(pos_max.x, src_rect.position.y),
+					pos_max,
+					Vector2(src_rect.position.x, pos_max.y),
+				};
+
+				if (rect->flags & CANVAS_RECT_TRANSPOSE) {
+					SWAP(uvs[1], uvs[3]);
+				}
 
-	} else {
-		glDisableVertexAttribArray(VS::ARRAY_WEIGHTS);
-		glDisableVertexAttribArray(VS::ARRAY_BONES);
-	}
+				if (rect->flags & CANVAS_RECT_FLIP_H) {
+					SWAP(uvs[0], uvs[1]);
+					SWAP(uvs[2], uvs[3]);
+				}
+				if (rect->flags & CANVAS_RECT_FLIP_V) {
+					SWAP(uvs[0], uvs[3]);
+					SWAP(uvs[1], uvs[2]);
+				}
 
-	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, data.polygon_index_buffer);
-#ifndef GLES_OVER_GL
-	// Orphan the buffer to avoid CPU/GPU sync points caused by glBufferSubData
-	glBufferData(GL_ELEMENT_ARRAY_BUFFER, data.polygon_index_buffer_size, NULL, GL_DYNAMIC_DRAW);
-#endif
+				bA->uv.set(uvs[0]);
+				bB->uv.set(uvs[1]);
+				bC->uv.set(uvs[2]);
+				bD->uv.set(uvs[3]);
 
-	if (storage->config.support_32_bits_indices) { //should check for
-		glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, 0, sizeof(int) * p_index_count, p_indices);
-		glDrawElements(GL_TRIANGLES, p_index_count, GL_UNSIGNED_INT, 0);
-	} else {
-		uint16_t *index16 = (uint16_t *)alloca(sizeof(uint16_t) * p_index_count);
-		for (int i = 0; i < p_index_count; i++) {
-			index16[i] = uint16_t(p_indices[i]);
+				// increment quad count
+				bdata.total_quads++;
+
+			} break;
 		}
-		glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, 0, sizeof(uint16_t) * p_index_count, index16);
-		glDrawElements(GL_TRIANGLES, p_index_count, GL_UNSIGNED_SHORT, 0);
 	}
 
-	glBindBuffer(GL_ARRAY_BUFFER, 0);
-	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-}
+	// VERY IMPORTANT to return where we got to, because this func may be called multiple
+	// times per item.
+	// Don't miss out on this step by calling return earlier in the function without setting r_command_start.
+	r_command_start = command_num;
 
-void RasterizerCanvasGLES2::_draw_generic(GLuint p_primitive, int p_vertex_count, const Vector2 *p_vertices, const Vector2 *p_uvs, const Color *p_colors, bool p_singlecolor) {
+	return false;
+}
 
-	glBindBuffer(GL_ARRAY_BUFFER, data.polygon_buffer);
-#ifndef GLES_OVER_GL
-	// Orphan the buffer to avoid CPU/GPU sync points caused by glBufferSubData
-	glBufferData(GL_ARRAY_BUFFER, data.polygon_buffer_size, NULL, GL_DYNAMIC_DRAW);
+// convert the stupidly high amount of batches (each with its own color)
+// to larger batches where the color is stored in the verts instead...
+// There is a trade off. Non colored verts are smaller so work faster, but
+// there comes a point where it is better to just use colored verts to avoid lots of
+// batches.
+void RasterizerCanvasGLES2::_batch_translate_to_colored() {
+	bdata.vertices_colored.reset();
+	bdata.batches_temp.reset();
+
+	// As the vertices_colored and batches_temp are 'mirrors' of the non-colored version,
+	// the sizes should be equal, and allocations should never fail. Hence the use of debug
+	// asserts to check program flow, these should not occur at runtime unless the allocation
+	// code has been altered.
+#ifdef DEBUG_ENABLED
+	CRASH_COND(bdata.vertices_colored.max_size() != bdata.vertices.max_size());
+	CRASH_COND(bdata.batches_temp.max_size() != bdata.batches.max_size());
 #endif
 
-	uint32_t buffer_ofs = 0;
+	Color curr_col(-1.0, -1.0, -1.0, -1.0);
 
-	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(Vector2) * p_vertex_count, p_vertices);
-	glEnableVertexAttribArray(VS::ARRAY_VERTEX);
-	glVertexAttribPointer(VS::ARRAY_VERTEX, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2), NULL);
-	buffer_ofs += sizeof(Vector2) * p_vertex_count;
+	Batch *d_batch = 0;
 
-	if (p_singlecolor) {
-		glDisableVertexAttribArray(VS::ARRAY_COLOR);
-		Color m = *p_colors;
-		glVertexAttrib4f(VS::ARRAY_COLOR, m.r, m.g, m.b, m.a);
-	} else if (!p_colors) {
-		glDisableVertexAttribArray(VS::ARRAY_COLOR);
-		glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
-	} else {
-		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(Color) * p_vertex_count, p_colors);
-		glEnableVertexAttribArray(VS::ARRAY_COLOR);
-		glVertexAttribPointer(VS::ARRAY_COLOR, 4, GL_FLOAT, GL_FALSE, sizeof(Color), CAST_INT_TO_UCHAR_PTR(buffer_ofs));
-		buffer_ofs += sizeof(Color) * p_vertex_count;
-	}
-
-	if (p_uvs) {
-		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(Vector2) * p_vertex_count, p_uvs);
-		glEnableVertexAttribArray(VS::ARRAY_TEX_UV);
-		glVertexAttribPointer(VS::ARRAY_TEX_UV, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2), CAST_INT_TO_UCHAR_PTR(buffer_ofs));
-	} else {
-		glDisableVertexAttribArray(VS::ARRAY_TEX_UV);
-	}
+	// translate the batches into vertex colored batches
+	for (int n = 0; n < bdata.batches.size(); n++) {
+		const Batch &s_batch = bdata.batches[n];
 
-	glDrawArrays(p_primitive, 0, p_vertex_count);
+		bool needs_new_batch;
 
-	glBindBuffer(GL_ARRAY_BUFFER, 0);
-}
+		if (d_batch) {
+			// is the d batch the same except for the color?
+			if ((d_batch->batch_texture_id == s_batch.batch_texture_id) && (d_batch->type == s_batch.type)) {
+				// add to previous batch
+				d_batch->num_commands += s_batch.num_commands;
+				needs_new_batch = false;
 
-void RasterizerCanvasGLES2::_draw_generic_indices(GLuint p_primitive, const int *p_indices, int p_index_count, int p_vertex_count, const Vector2 *p_vertices, const Vector2 *p_uvs, const Color *p_colors, bool p_singlecolor) {
+				// create the colored verts (only if not default)
+				if (s_batch.type != Batch::BT_DEFAULT) {
+					int first_vert = s_batch.first_quad * 4;
+					int end_vert = 4 * (s_batch.first_quad + s_batch.num_commands);
 
-	glBindBuffer(GL_ARRAY_BUFFER, data.polygon_buffer);
-#ifndef GLES_OVER_GL
-	// Orphan the buffer to avoid CPU/GPU sync points caused by glBufferSubData
-	glBufferData(GL_ARRAY_BUFFER, data.polygon_buffer_size, NULL, GL_DYNAMIC_DRAW);
+					for (int v = first_vert; v < end_vert; v++) {
+						const BatchVertex &bv = bdata.vertices[v];
+						BatchVertexColored *cv = bdata.vertices_colored.request();
+#ifdef DEBUG_ENABLED
+						CRASH_COND(!cv);
 #endif
+						cv->pos = bv.pos;
+						cv->uv = bv.uv;
+						cv->col = s_batch.color;
+					}
+				}
+			} else {
+				needs_new_batch = true;
+			}
+		} else {
+			needs_new_batch = true;
+		}
 
-	uint32_t buffer_ofs = 0;
-
-	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(Vector2) * p_vertex_count, p_vertices);
-	glEnableVertexAttribArray(VS::ARRAY_VERTEX);
-	glVertexAttribPointer(VS::ARRAY_VERTEX, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2), NULL);
-	buffer_ofs += sizeof(Vector2) * p_vertex_count;
+		if (needs_new_batch) {
+			d_batch = bdata.batches_temp.request();
+#ifdef DEBUG_ENABLED
+			CRASH_COND(!d_batch);
+#endif
 
-	if (p_singlecolor) {
-		glDisableVertexAttribArray(VS::ARRAY_COLOR);
-		Color m = *p_colors;
-		glVertexAttrib4f(VS::ARRAY_COLOR, m.r, m.g, m.b, m.a);
-	} else if (!p_colors) {
-		glDisableVertexAttribArray(VS::ARRAY_COLOR);
-		glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
-	} else {
-		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(Color) * p_vertex_count, p_colors);
-		glEnableVertexAttribArray(VS::ARRAY_COLOR);
-		glVertexAttribPointer(VS::ARRAY_COLOR, 4, GL_FLOAT, GL_FALSE, sizeof(Color), CAST_INT_TO_UCHAR_PTR(buffer_ofs));
-		buffer_ofs += sizeof(Color) * p_vertex_count;
-	}
+			*d_batch = s_batch;
 
-	if (p_uvs) {
-		glBufferSubData(GL_ARRAY_BUFFER, buffer_ofs, sizeof(Vector2) * p_vertex_count, p_uvs);
-		glEnableVertexAttribArray(VS::ARRAY_TEX_UV);
-		glVertexAttribPointer(VS::ARRAY_TEX_UV, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2), CAST_INT_TO_UCHAR_PTR(buffer_ofs));
-		buffer_ofs += sizeof(Vector2) * p_vertex_count;
-	} else {
-		glDisableVertexAttribArray(VS::ARRAY_TEX_UV);
-	}
+			// create the colored verts (only if not default)
+			if (s_batch.type != Batch::BT_DEFAULT) {
+				int first_vert = s_batch.first_quad * 4;
+				int end_vert = 4 * (s_batch.first_quad + s_batch.num_commands);
 
-	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, data.polygon_index_buffer);
-#ifndef GLES_OVER_GL
-	// Orphan the buffer to avoid CPU/GPU sync points caused by glBufferSubData
-	glBufferData(GL_ELEMENT_ARRAY_BUFFER, data.polygon_index_buffer_size, NULL, GL_DYNAMIC_DRAW);
+				for (int v = first_vert; v < end_vert; v++) {
+					const BatchVertex &bv = bdata.vertices[v];
+					BatchVertexColored *cv = bdata.vertices_colored.request();
+#ifdef DEBUG_ENABLED
+					CRASH_COND(!cv);
 #endif
-
-	if (storage->config.support_32_bits_indices) { //should check for
-		glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, 0, sizeof(int) * p_index_count, p_indices);
-		glDrawElements(p_primitive, p_index_count, GL_UNSIGNED_INT, 0);
-	} else {
-		uint16_t *index16 = (uint16_t *)alloca(sizeof(uint16_t) * p_index_count);
-		for (int i = 0; i < p_index_count; i++) {
-			index16[i] = uint16_t(p_indices[i]);
+					cv->pos = bv.pos;
+					cv->uv = bv.uv;
+					cv->col = s_batch.color;
+				}
+			}
 		}
-		glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, 0, sizeof(uint16_t) * p_index_count, index16);
-		glDrawElements(p_primitive, p_index_count, GL_UNSIGNED_SHORT, 0);
 	}
 
-	glBindBuffer(GL_ARRAY_BUFFER, 0);
-	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+	// copy the temporary batches to the master batch list (this could be avoided but it makes the code cleaner)
+	bdata.batches.copy_from(bdata.batches_temp);
 }
 
-void RasterizerCanvasGLES2::_draw_gui_primitive(int p_points, const Vector2 *p_vertices, const Color *p_colors, const Vector2 *p_uvs) {
-
-	static const GLenum prim[5] = { GL_POINTS, GL_POINTS, GL_LINES, GL_TRIANGLES, GL_TRIANGLE_FAN };
+void RasterizerCanvasGLES2::_batch_render_rects(const Batch &batch, RasterizerStorageGLES2::Material *p_material) {
 
-	int color_offset = 0;
-	int uv_offset = 0;
-	int stride = 2;
+	ERR_FAIL_COND(batch.num_commands <= 0);
 
-	if (p_colors) {
-		color_offset = stride;
-		stride += 4;
-	}
-
-	if (p_uvs) {
-		uv_offset = stride;
-		stride += 2;
+	const bool &colored_verts = bdata.use_colored_vertices;
+	int sizeof_vert;
+	if (!colored_verts) {
+		sizeof_vert = sizeof(BatchVertex);
+	} else {
+		sizeof_vert = sizeof(BatchVertexColored);
 	}
 
-	float buffer_data[(2 + 2 + 4) * 4];
+	state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
 
-	for (int i = 0; i < p_points; i++) {
-		buffer_data[stride * i + 0] = p_vertices[i].x;
-		buffer_data[stride * i + 1] = p_vertices[i].y;
+	if (state.canvas_shader.bind()) {
+		_set_uniforms();
+		state.canvas_shader.use_material((void *)p_material);
 	}
 
-	if (p_colors) {
-		for (int i = 0; i < p_points; i++) {
-			buffer_data[stride * i + color_offset + 0] = p_colors[i].r;
-			buffer_data[stride * i + color_offset + 1] = p_colors[i].g;
-			buffer_data[stride * i + color_offset + 2] = p_colors[i].b;
-			buffer_data[stride * i + color_offset + 3] = p_colors[i].a;
-		}
-	}
+	// batch tex
+	const BatchTex &tex = bdata.batch_textures[batch.batch_texture_id];
 
-	if (p_uvs) {
-		for (int i = 0; i < p_points; i++) {
-			buffer_data[stride * i + uv_offset + 0] = p_uvs[i].x;
-			buffer_data[stride * i + uv_offset + 1] = p_uvs[i].y;
-		}
-	}
+	RasterizerStorageGLES2::Texture *texture = _bind_canvas_texture(tex.RID_texture, tex.RID_normal);
 
-	glBindBuffer(GL_ARRAY_BUFFER, data.polygon_buffer);
-#ifndef GLES_OVER_GL
-	// Orphan the buffer to avoid CPU/GPU sync points caused by glBufferSubData
-	glBufferData(GL_ARRAY_BUFFER, data.polygon_buffer_size, NULL, GL_DYNAMIC_DRAW);
-#endif
-	glBufferSubData(GL_ARRAY_BUFFER, 0, p_points * stride * 4 * sizeof(float), buffer_data);
+	// bind the index and vertex buffer
+	glBindBuffer(GL_ARRAY_BUFFER, bdata.gl_vertex_buffer);
+	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bdata.gl_index_buffer);
+
+	uint64_t pointer = 0;
+	glVertexAttribPointer(VS::ARRAY_VERTEX, 2, GL_FLOAT, GL_FALSE, sizeof_vert, (const void *)pointer);
 
-	glVertexAttribPointer(VS::ARRAY_VERTEX, 2, GL_FLOAT, GL_FALSE, stride * sizeof(float), NULL);
+	if (texture) {
+		glVertexAttribPointer(VS::ARRAY_TEX_UV, 2, GL_FLOAT, GL_FALSE, sizeof_vert, CAST_INT_TO_UCHAR_PTR(pointer + (2 * 4)));
+		glEnableVertexAttribArray(VS::ARRAY_TEX_UV);
+	} else {
+		glDisableVertexAttribArray(VS::ARRAY_TEX_UV);
+	}
 
-	if (p_colors) {
-		glVertexAttribPointer(VS::ARRAY_COLOR, 4, GL_FLOAT, GL_FALSE, stride * sizeof(float), CAST_INT_TO_UCHAR_PTR(color_offset * sizeof(float)));
+	// color
+	if (!colored_verts) {
+		glDisableVertexAttribArray(VS::ARRAY_COLOR);
+		glVertexAttrib4fv(VS::ARRAY_COLOR, batch.color.get_data());
+	} else {
+		glVertexAttribPointer(VS::ARRAY_COLOR, 4, GL_FLOAT, GL_FALSE, sizeof_vert, CAST_INT_TO_UCHAR_PTR(pointer + (4 * 4)));
 		glEnableVertexAttribArray(VS::ARRAY_COLOR);
 	}
 
-	if (p_uvs) {
-		glVertexAttribPointer(VS::ARRAY_TEX_UV, 2, GL_FLOAT, GL_FALSE, stride * sizeof(float), CAST_INT_TO_UCHAR_PTR(uv_offset * sizeof(float)));
-		glEnableVertexAttribArray(VS::ARRAY_TEX_UV);
+	switch (tex.tile_mode) {
+		case BatchTex::TILE_FORCE_REPEAT: {
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_FORCE_REPEAT, true);
+		} break;
+		case BatchTex::TILE_NORMAL: {
+			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+		} break;
+		default: {
+		} break;
+	}
+
+	// we need to convert explicitly from pod Vec2 to Vector2 ...
+	// could use a cast but this might be unsafe in future
+	Vector2 tps;
+	tex.tex_pixel_size.to(tps);
+	state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, tps);
+
+	int64_t offset = batch.first_quad * 6 * 2; // 6 inds per quad at 2 bytes each
+
+	int num_elements = batch.num_commands * 6;
+	glDrawElements(GL_TRIANGLES, num_elements, GL_UNSIGNED_SHORT, (void *)offset);
+
+	switch (tex.tile_mode) {
+		case BatchTex::TILE_FORCE_REPEAT: {
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_FORCE_REPEAT, false);
+		} break;
+		case BatchTex::TILE_NORMAL: {
+			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+		} break;
+		default: {
+		} break;
 	}
 
-	glDrawArrays(prim[p_points], 0, p_points);
+	glDisableVertexAttribArray(VS::ARRAY_TEX_UV);
+	glDisableVertexAttribArray(VS::ARRAY_COLOR);
 
+	// may not be necessary .. state change optimization still TODO
 	glBindBuffer(GL_ARRAY_BUFFER, 0);
+	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
 }
 
-static const GLenum gl_primitive[] = {
-	GL_POINTS,
-	GL_LINES,
-	GL_LINE_STRIP,
-	GL_LINE_LOOP,
-	GL_TRIANGLES,
-	GL_TRIANGLE_STRIP,
-	GL_TRIANGLE_FAN
-};
+void RasterizerCanvasGLES2::render_batches(Item::Command *const *commands, int first_item_ref_id, Item *current_clip, bool &reclip, RasterizerStorageGLES2::Material *p_material) {
+	//	Item *p_item = 0;
+	//	Item::Command * const *commands = p_item->commands.ptr();
+	//	Item::Command * const *commands = 0;
 
-void RasterizerCanvasGLES2::_canvas_item_render_commands(Item *p_item, Item *current_clip, bool &reclip, RasterizerStorageGLES2::Material *p_material) {
+	int num_batches = bdata.batches.size();
 
-	int command_count = p_item->commands.size();
-	Item::Command **commands = p_item->commands.ptrw();
+	for (int batch_num = 0; batch_num < num_batches; batch_num++) {
+		const Batch &batch = bdata.batches[batch_num];
 
-	for (int i = 0; i < command_count; i++) {
+		switch (batch.type) {
+			case Batch::BT_RECT: {
+				_batch_render_rects(batch, p_material);
+			} break;
+			default: {
+				int end_command = batch.first_command + batch.num_commands;
 
-		Item::Command *command = commands[i];
+				for (int i = batch.first_command; i < end_command; i++) {
 
-		switch (command->type) {
+					Item::Command *command = commands[i];
 
-			case Item::Command::TYPE_LINE: {
+					switch (command->type) {
 
-				Item::CommandLine *line = static_cast<Item::CommandLine *>(command);
+						case Item::Command::TYPE_LINE: {
 
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
-				if (state.canvas_shader.bind()) {
-					_set_uniforms();
-					state.canvas_shader.use_material((void *)p_material);
-				}
+							Item::CommandLine *line = static_cast<Item::CommandLine *>(command);
 
-				_bind_canvas_texture(RID(), RID());
+							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
+							if (state.canvas_shader.bind()) {
+								_set_uniforms();
+								state.canvas_shader.use_material((void *)p_material);
+							}
+
+							_bind_canvas_texture(RID(), RID());
 
-				glDisableVertexAttribArray(VS::ARRAY_COLOR);
-				glVertexAttrib4fv(VS::ARRAY_COLOR, line->color.components);
+							glDisableVertexAttribArray(VS::ARRAY_COLOR);
+							glVertexAttrib4fv(VS::ARRAY_COLOR, line->color.components);
 
-				state.canvas_shader.set_uniform(CanvasShaderGLES2::MODELVIEW_MATRIX, state.uniforms.modelview_matrix);
+							state.canvas_shader.set_uniform(CanvasShaderGLES2::MODELVIEW_MATRIX, state.uniforms.modelview_matrix);
 
-				if (line->width <= 1) {
-					Vector2 verts[2] = {
-						Vector2(line->from.x, line->from.y),
-						Vector2(line->to.x, line->to.y)
-					};
+							if (line->width <= 1) {
+								Vector2 verts[2] = {
+									Vector2(line->from.x, line->from.y),
+									Vector2(line->to.x, line->to.y)
+								};
 
 #ifdef GLES_OVER_GL
-					if (line->antialiased)
-						glEnable(GL_LINE_SMOOTH);
+								if (line->antialiased)
+									glEnable(GL_LINE_SMOOTH);
 #endif
-					_draw_gui_primitive(2, verts, NULL, NULL);
+								_draw_gui_primitive(2, verts, NULL, NULL);
 
 #ifdef GLES_OVER_GL
-					if (line->antialiased)
-						glDisable(GL_LINE_SMOOTH);
+								if (line->antialiased)
+									glDisable(GL_LINE_SMOOTH);
 #endif
-				} else {
-					Vector2 t = (line->from - line->to).normalized().tangent() * line->width * 0.5;
+							} else {
+								Vector2 t = (line->from - line->to).normalized().tangent() * line->width * 0.5;
 
-					Vector2 verts[4] = {
-						line->from - t,
-						line->from + t,
-						line->to + t,
-						line->to - t
-					};
+								Vector2 verts[4] = {
+									line->from - t,
+									line->from + t,
+									line->to + t,
+									line->to - t
+								};
 
-					_draw_gui_primitive(4, verts, NULL, NULL);
+								_draw_gui_primitive(4, verts, NULL, NULL);
 #ifdef GLES_OVER_GL
-					if (line->antialiased) {
-						glEnable(GL_LINE_SMOOTH);
-						for (int j = 0; j < 4; j++) {
-							Vector2 vertsl[2] = {
-								verts[j],
-								verts[(j + 1) % 4],
-							};
-							_draw_gui_primitive(2, vertsl, NULL, NULL);
-						}
-						glDisable(GL_LINE_SMOOTH);
-					}
+								if (line->antialiased) {
+									glEnable(GL_LINE_SMOOTH);
+									for (int j = 0; j < 4; j++) {
+										Vector2 vertsl[2] = {
+											verts[j],
+											verts[(j + 1) % 4],
+										};
+										_draw_gui_primitive(2, vertsl, NULL, NULL);
+									}
+									glDisable(GL_LINE_SMOOTH);
+								}
 #endif
-				}
-			} break;
+							}
+						} break;
 
-			case Item::Command::TYPE_RECT: {
+						case Item::Command::TYPE_RECT: {
 
-				Item::CommandRect *r = static_cast<Item::CommandRect *>(command);
+							Item::CommandRect *r = static_cast<Item::CommandRect *>(command);
 
-				glDisableVertexAttribArray(VS::ARRAY_COLOR);
-				glVertexAttrib4fv(VS::ARRAY_COLOR, r->modulate.components);
+							glDisableVertexAttribArray(VS::ARRAY_COLOR);
+							glVertexAttrib4fv(VS::ARRAY_COLOR, r->modulate.components);
 
-				bool can_tile = true;
-				if (r->texture.is_valid() && r->flags & CANVAS_RECT_TILE && !storage->config.support_npot_repeat_mipmap) {
-					// workaround for when setting tiling does not work due to hardware limitation
+							bool can_tile = true;
+							if (r->texture.is_valid() && r->flags & CANVAS_RECT_TILE && !storage->config.support_npot_repeat_mipmap) {
+								// workaround for when setting tiling does not work due to hardware limitation
 
-					RasterizerStorageGLES2::Texture *texture = storage->texture_owner.getornull(r->texture);
+								RasterizerStorageGLES2::Texture *texture = storage->texture_owner.getornull(r->texture);
 
-					if (texture) {
+								if (texture) {
 
-						texture = texture->get_ptr();
+									texture = texture->get_ptr();
 
-						if (next_power_of_2(texture->alloc_width) != (unsigned int)texture->alloc_width && next_power_of_2(texture->alloc_height) != (unsigned int)texture->alloc_height) {
-							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_FORCE_REPEAT, true);
-							can_tile = false;
-						}
-					}
-				}
+									if (next_power_of_2(texture->alloc_width) != (unsigned int)texture->alloc_width && next_power_of_2(texture->alloc_height) != (unsigned int)texture->alloc_height) {
+										state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_FORCE_REPEAT, true);
+										can_tile = false;
+									}
+								}
+							}
 
-				// On some widespread Nvidia cards, the normal draw method can produce some
-				// flickering in draw_rect and especially TileMap rendering (tiles randomly flicker).
-				// See GH-9913.
-				// To work it around, we use a simpler draw method which does not flicker, but gives
-				// a non negligible performance hit, so it's opt-in (GH-24466).
-				if (use_nvidia_rect_workaround) {
-					state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
-
-					if (state.canvas_shader.bind()) {
-						_set_uniforms();
-						state.canvas_shader.use_material((void *)p_material);
-					}
+							// On some widespread Nvidia cards, the normal draw method can produce some
+							// flickering in draw_rect and especially TileMap rendering (tiles randomly flicker).
+							// See GH-9913.
+							// To work it around, we use a simpler draw method which does not flicker, but gives
+							// a non negligible performance hit, so it's opt-in (GH-24466).
+							if (use_nvidia_rect_workaround) {
+								state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
+
+								if (state.canvas_shader.bind()) {
+									_set_uniforms();
+									state.canvas_shader.use_material((void *)p_material);
+								}
 
-					Vector2 points[4] = {
-						r->rect.position,
-						r->rect.position + Vector2(r->rect.size.x, 0.0),
-						r->rect.position + r->rect.size,
-						r->rect.position + Vector2(0.0, r->rect.size.y),
-					};
+								Vector2 points[4] = {
+									r->rect.position,
+									r->rect.position + Vector2(r->rect.size.x, 0.0),
+									r->rect.position + r->rect.size,
+									r->rect.position + Vector2(0.0, r->rect.size.y),
+								};
 
-					if (r->rect.size.x < 0) {
-						SWAP(points[0], points[1]);
-						SWAP(points[2], points[3]);
-					}
-					if (r->rect.size.y < 0) {
-						SWAP(points[0], points[3]);
-						SWAP(points[1], points[2]);
-					}
+								if (r->rect.size.x < 0) {
+									SWAP(points[0], points[1]);
+									SWAP(points[2], points[3]);
+								}
+								if (r->rect.size.y < 0) {
+									SWAP(points[0], points[3]);
+									SWAP(points[1], points[2]);
+								}
 
-					RasterizerStorageGLES2::Texture *texture = _bind_canvas_texture(r->texture, r->normal_map);
-
-					if (texture) {
-						Size2 texpixel_size(1.0 / texture->width, 1.0 / texture->height);
-
-						Rect2 src_rect = (r->flags & CANVAS_RECT_REGION) ? Rect2(r->source.position * texpixel_size, r->source.size * texpixel_size) : Rect2(0, 0, 1, 1);
-
-						Vector2 uvs[4] = {
-							src_rect.position,
-							src_rect.position + Vector2(src_rect.size.x, 0.0),
-							src_rect.position + src_rect.size,
-							src_rect.position + Vector2(0.0, src_rect.size.y),
-						};
-
-						if (r->flags & CANVAS_RECT_TRANSPOSE) {
-							SWAP(uvs[1], uvs[3]);
-						}
-
-						if (r->flags & CANVAS_RECT_FLIP_H) {
-							SWAP(uvs[0], uvs[1]);
-							SWAP(uvs[2], uvs[3]);
-						}
-						if (r->flags & CANVAS_RECT_FLIP_V) {
-							SWAP(uvs[0], uvs[3]);
-							SWAP(uvs[1], uvs[2]);
-						}
-
-						state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
-
-						bool untile = false;
-
-						if (can_tile && r->flags & CANVAS_RECT_TILE && !(texture->flags & VS::TEXTURE_FLAG_REPEAT)) {
-							glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
-							glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
-							untile = true;
-						}
-
-						_draw_gui_primitive(4, points, NULL, uvs);
-
-						if (untile) {
-							glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-							glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-						}
-					} else {
-						static const Vector2 uvs[4] = {
-							Vector2(0.0, 0.0),
-							Vector2(0.0, 1.0),
-							Vector2(1.0, 1.0),
-							Vector2(1.0, 0.0),
-						};
-
-						state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, Vector2());
-						_draw_gui_primitive(4, points, NULL, uvs);
-					}
+								RasterizerStorageGLES2::Texture *texture = _bind_canvas_texture(r->texture, r->normal_map);
 
-				} else {
-					// This branch is better for performance, but can produce flicker on Nvidia, see above comment.
-					_bind_quad_buffer();
+								if (texture) {
+									Size2 texpixel_size(1.0 / texture->width, 1.0 / texture->height);
 
-					state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, true);
+									Rect2 src_rect = (r->flags & CANVAS_RECT_REGION) ? Rect2(r->source.position * texpixel_size, r->source.size * texpixel_size) : Rect2(0, 0, 1, 1);
 
-					if (state.canvas_shader.bind()) {
-						_set_uniforms();
-						state.canvas_shader.use_material((void *)p_material);
-					}
+									Vector2 uvs[4] = {
+										src_rect.position,
+										src_rect.position + Vector2(src_rect.size.x, 0.0),
+										src_rect.position + src_rect.size,
+										src_rect.position + Vector2(0.0, src_rect.size.y),
+									};
 
-					RasterizerStorageGLES2::Texture *tex = _bind_canvas_texture(r->texture, r->normal_map);
+									if (r->flags & CANVAS_RECT_TRANSPOSE) {
+										SWAP(uvs[1], uvs[3]);
+									}
 
-					if (!tex) {
-						Rect2 dst_rect = Rect2(r->rect.position, r->rect.size);
+									if (r->flags & CANVAS_RECT_FLIP_H) {
+										SWAP(uvs[0], uvs[1]);
+										SWAP(uvs[2], uvs[3]);
+									}
+									if (r->flags & CANVAS_RECT_FLIP_V) {
+										SWAP(uvs[0], uvs[3]);
+										SWAP(uvs[1], uvs[2]);
+									}
 
-						if (dst_rect.size.width < 0) {
-							dst_rect.position.x += dst_rect.size.width;
-							dst_rect.size.width *= -1;
-						}
-						if (dst_rect.size.height < 0) {
-							dst_rect.position.y += dst_rect.size.height;
-							dst_rect.size.height *= -1;
-						}
+									state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
 
-						state.canvas_shader.set_uniform(CanvasShaderGLES2::DST_RECT, Color(dst_rect.position.x, dst_rect.position.y, dst_rect.size.x, dst_rect.size.y));
-						state.canvas_shader.set_uniform(CanvasShaderGLES2::SRC_RECT, Color(0, 0, 1, 1));
+									bool untile = false;
 
-						glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
-					} else {
+									if (can_tile && r->flags & CANVAS_RECT_TILE && !(texture->flags & VS::TEXTURE_FLAG_REPEAT)) {
+										glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+										glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+										untile = true;
+									}
 
-						bool untile = false;
+									_draw_gui_primitive(4, points, NULL, uvs);
 
-						if (can_tile && r->flags & CANVAS_RECT_TILE && !(tex->flags & VS::TEXTURE_FLAG_REPEAT)) {
-							glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
-							glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
-							untile = true;
-						}
+									if (untile) {
+										glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+										glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+									}
+								} else {
+									static const Vector2 uvs[4] = {
+										Vector2(0.0, 0.0),
+										Vector2(0.0, 1.0),
+										Vector2(1.0, 1.0),
+										Vector2(1.0, 0.0),
+									};
+
+									state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, Vector2());
+									_draw_gui_primitive(4, points, NULL, uvs);
+								}
 
-						Size2 texpixel_size(1.0 / tex->width, 1.0 / tex->height);
-						Rect2 src_rect = (r->flags & CANVAS_RECT_REGION) ? Rect2(r->source.position * texpixel_size, r->source.size * texpixel_size) : Rect2(0, 0, 1, 1);
+							} else {
+								// This branch is better for performance, but can produce flicker on Nvidia, see above comment.
+								_bind_quad_buffer();
 
-						Rect2 dst_rect = Rect2(r->rect.position, r->rect.size);
+								state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, true);
 
-						if (dst_rect.size.width < 0) {
-							dst_rect.position.x += dst_rect.size.width;
-							dst_rect.size.width *= -1;
-						}
-						if (dst_rect.size.height < 0) {
-							dst_rect.position.y += dst_rect.size.height;
-							dst_rect.size.height *= -1;
-						}
+								if (state.canvas_shader.bind()) {
+									_set_uniforms();
+									state.canvas_shader.use_material((void *)p_material);
+								}
 
-						if (r->flags & CANVAS_RECT_FLIP_H) {
-							src_rect.size.x *= -1;
-						}
+								RasterizerStorageGLES2::Texture *tex = _bind_canvas_texture(r->texture, r->normal_map);
 
-						if (r->flags & CANVAS_RECT_FLIP_V) {
-							src_rect.size.y *= -1;
-						}
+								if (!tex) {
+									Rect2 dst_rect = Rect2(r->rect.position, r->rect.size);
 
-						if (r->flags & CANVAS_RECT_TRANSPOSE) {
-							dst_rect.size.x *= -1; // Encoding in the dst_rect.z uniform
-						}
+									if (dst_rect.size.width < 0) {
+										dst_rect.position.x += dst_rect.size.width;
+										dst_rect.size.width *= -1;
+									}
+									if (dst_rect.size.height < 0) {
+										dst_rect.position.y += dst_rect.size.height;
+										dst_rect.size.height *= -1;
+									}
 
-						state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
+									state.canvas_shader.set_uniform(CanvasShaderGLES2::DST_RECT, Color(dst_rect.position.x, dst_rect.position.y, dst_rect.size.x, dst_rect.size.y));
+									state.canvas_shader.set_uniform(CanvasShaderGLES2::SRC_RECT, Color(0, 0, 1, 1));
 
-						state.canvas_shader.set_uniform(CanvasShaderGLES2::DST_RECT, Color(dst_rect.position.x, dst_rect.position.y, dst_rect.size.x, dst_rect.size.y));
-						state.canvas_shader.set_uniform(CanvasShaderGLES2::SRC_RECT, Color(src_rect.position.x, src_rect.position.y, src_rect.size.x, src_rect.size.y));
+									glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+								} else {
 
-						glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+									bool untile = false;
 
-						if (untile) {
-							glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-							glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-						}
-					}
+									if (can_tile && r->flags & CANVAS_RECT_TILE && !(tex->flags & VS::TEXTURE_FLAG_REPEAT)) {
+										glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+										glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+										untile = true;
+									}
 
-					glBindBuffer(GL_ARRAY_BUFFER, 0);
-					glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-				}
+									Size2 texpixel_size(1.0 / tex->width, 1.0 / tex->height);
+									Rect2 src_rect = (r->flags & CANVAS_RECT_REGION) ? Rect2(r->source.position * texpixel_size, r->source.size * texpixel_size) : Rect2(0, 0, 1, 1);
 
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_FORCE_REPEAT, false);
+									Rect2 dst_rect = Rect2(r->rect.position, r->rect.size);
 
-			} break;
+									if (dst_rect.size.width < 0) {
+										dst_rect.position.x += dst_rect.size.width;
+										dst_rect.size.width *= -1;
+									}
+									if (dst_rect.size.height < 0) {
+										dst_rect.position.y += dst_rect.size.height;
+										dst_rect.size.height *= -1;
+									}
 
-			case Item::Command::TYPE_NINEPATCH: {
+									if (r->flags & CANVAS_RECT_FLIP_H) {
+										src_rect.size.x *= -1;
+									}
 
-				Item::CommandNinePatch *np = static_cast<Item::CommandNinePatch *>(command);
+									if (r->flags & CANVAS_RECT_FLIP_V) {
+										src_rect.size.y *= -1;
+									}
 
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
-				if (state.canvas_shader.bind()) {
-					_set_uniforms();
-					state.canvas_shader.use_material((void *)p_material);
-				}
+									if (r->flags & CANVAS_RECT_TRANSPOSE) {
+										dst_rect.size.x *= -1; // Encoding in the dst_rect.z uniform
+									}
 
-				glDisableVertexAttribArray(VS::ARRAY_COLOR);
-				glVertexAttrib4fv(VS::ARRAY_COLOR, np->color.components);
+									state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
 
-				RasterizerStorageGLES2::Texture *tex = _bind_canvas_texture(np->texture, np->normal_map);
+									state.canvas_shader.set_uniform(CanvasShaderGLES2::DST_RECT, Color(dst_rect.position.x, dst_rect.position.y, dst_rect.size.x, dst_rect.size.y));
+									state.canvas_shader.set_uniform(CanvasShaderGLES2::SRC_RECT, Color(src_rect.position.x, src_rect.position.y, src_rect.size.x, src_rect.size.y));
 
-				if (!tex) {
-					// FIXME: Handle textureless ninepatch gracefully
-					WARN_PRINT("NinePatch without texture not supported yet in GLES2 backend, skipping.");
-					continue;
-				}
-				if (tex->width == 0 || tex->height == 0) {
-					WARN_PRINT("Cannot set empty texture to NinePatch.");
-					continue;
-				}
+									glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
 
-				Size2 texpixel_size(1.0 / tex->width, 1.0 / tex->height);
+									if (untile) {
+										glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+										glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+									}
+								}
 
-				// state.canvas_shader.set_uniform(CanvasShaderGLES2::MODELVIEW_MATRIX, state.uniforms.modelview_matrix);
-				state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
+								glBindBuffer(GL_ARRAY_BUFFER, 0);
+								glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+							}
 
-				Rect2 source = np->source;
-				if (source.size.x == 0 && source.size.y == 0) {
-					source.size.x = tex->width;
-					source.size.y = tex->height;
-				}
+							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_FORCE_REPEAT, false);
 
-				float screen_scale = 1.0;
+						} break;
 
-				if (source.size.x != 0 && source.size.y != 0) {
+						case Item::Command::TYPE_NINEPATCH: {
 
-					screen_scale = MIN(np->rect.size.x / source.size.x, np->rect.size.y / source.size.y);
-					screen_scale = MIN(1.0, screen_scale);
-				}
+							Item::CommandNinePatch *np = static_cast<Item::CommandNinePatch *>(command);
 
-				// prepare vertex buffer
+							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
+							if (state.canvas_shader.bind()) {
+								_set_uniforms();
+								state.canvas_shader.use_material((void *)p_material);
+							}
 
-				// this buffer contains [ POS POS UV UV ] *
+							glDisableVertexAttribArray(VS::ARRAY_COLOR);
+							glVertexAttrib4fv(VS::ARRAY_COLOR, np->color.components);
 
-				float buffer[16 * 2 + 16 * 2];
+							RasterizerStorageGLES2::Texture *tex = _bind_canvas_texture(np->texture, np->normal_map);
 
-				{
+							if (!tex) {
+								// FIXME: Handle textureless ninepatch gracefully
+								WARN_PRINT("NinePatch without texture not supported yet in GLES2 backend, skipping.");
+								continue;
+							}
+							if (tex->width == 0 || tex->height == 0) {
+								WARN_PRINT("Cannot set empty texture to NinePatch.");
+								continue;
+							}
 
-					// first row
+							Size2 texpixel_size(1.0 / tex->width, 1.0 / tex->height);
 
-					buffer[(0 * 4 * 4) + 0] = np->rect.position.x;
-					buffer[(0 * 4 * 4) + 1] = np->rect.position.y;
+							// state.canvas_shader.set_uniform(CanvasShaderGLES2::MODELVIEW_MATRIX, state.uniforms.modelview_matrix);
+							state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
 
-					buffer[(0 * 4 * 4) + 2] = source.position.x * texpixel_size.x;
-					buffer[(0 * 4 * 4) + 3] = source.position.y * texpixel_size.y;
+							Rect2 source = np->source;
+							if (source.size.x == 0 && source.size.y == 0) {
+								source.size.x = tex->width;
+								source.size.y = tex->height;
+							}
 
-					buffer[(0 * 4 * 4) + 4] = np->rect.position.x + np->margin[MARGIN_LEFT] * screen_scale;
-					buffer[(0 * 4 * 4) + 5] = np->rect.position.y;
+							float screen_scale = 1.0;
 
-					buffer[(0 * 4 * 4) + 6] = (source.position.x + np->margin[MARGIN_LEFT]) * texpixel_size.x;
-					buffer[(0 * 4 * 4) + 7] = source.position.y * texpixel_size.y;
+							if (source.size.x != 0 && source.size.y != 0) {
 
-					buffer[(0 * 4 * 4) + 8] = np->rect.position.x + np->rect.size.x - np->margin[MARGIN_RIGHT] * screen_scale;
-					buffer[(0 * 4 * 4) + 9] = np->rect.position.y;
+								screen_scale = MIN(np->rect.size.x / source.size.x, np->rect.size.y / source.size.y);
+								screen_scale = MIN(1.0, screen_scale);
+							}
 
-					buffer[(0 * 4 * 4) + 10] = (source.position.x + source.size.x - np->margin[MARGIN_RIGHT]) * texpixel_size.x;
-					buffer[(0 * 4 * 4) + 11] = source.position.y * texpixel_size.y;
+							// prepare vertex buffer
 
-					buffer[(0 * 4 * 4) + 12] = np->rect.position.x + np->rect.size.x;
-					buffer[(0 * 4 * 4) + 13] = np->rect.position.y;
+							// this buffer contains [ POS POS UV UV ] *
 
-					buffer[(0 * 4 * 4) + 14] = (source.position.x + source.size.x) * texpixel_size.x;
-					buffer[(0 * 4 * 4) + 15] = source.position.y * texpixel_size.y;
+							float buffer[16 * 2 + 16 * 2];
 
-					// second row
+							{
 
-					buffer[(1 * 4 * 4) + 0] = np->rect.position.x;
-					buffer[(1 * 4 * 4) + 1] = np->rect.position.y + np->margin[MARGIN_TOP] * screen_scale;
+								// first row
 
-					buffer[(1 * 4 * 4) + 2] = source.position.x * texpixel_size.x;
-					buffer[(1 * 4 * 4) + 3] = (source.position.y + np->margin[MARGIN_TOP]) * texpixel_size.y;
+								buffer[(0 * 4 * 4) + 0] = np->rect.position.x;
+								buffer[(0 * 4 * 4) + 1] = np->rect.position.y;
 
-					buffer[(1 * 4 * 4) + 4] = np->rect.position.x + np->margin[MARGIN_LEFT] * screen_scale;
-					buffer[(1 * 4 * 4) + 5] = np->rect.position.y + np->margin[MARGIN_TOP] * screen_scale;
+								buffer[(0 * 4 * 4) + 2] = source.position.x * texpixel_size.x;
+								buffer[(0 * 4 * 4) + 3] = source.position.y * texpixel_size.y;
 
-					buffer[(1 * 4 * 4) + 6] = (source.position.x + np->margin[MARGIN_LEFT]) * texpixel_size.x;
-					buffer[(1 * 4 * 4) + 7] = (source.position.y + np->margin[MARGIN_TOP]) * texpixel_size.y;
+								buffer[(0 * 4 * 4) + 4] = np->rect.position.x + np->margin[MARGIN_LEFT] * screen_scale;
+								buffer[(0 * 4 * 4) + 5] = np->rect.position.y;
 
-					buffer[(1 * 4 * 4) + 8] = np->rect.position.x + np->rect.size.x - np->margin[MARGIN_RIGHT] * screen_scale;
-					buffer[(1 * 4 * 4) + 9] = np->rect.position.y + np->margin[MARGIN_TOP] * screen_scale;
+								buffer[(0 * 4 * 4) + 6] = (source.position.x + np->margin[MARGIN_LEFT]) * texpixel_size.x;
+								buffer[(0 * 4 * 4) + 7] = source.position.y * texpixel_size.y;
 
-					buffer[(1 * 4 * 4) + 10] = (source.position.x + source.size.x - np->margin[MARGIN_RIGHT]) * texpixel_size.x;
-					buffer[(1 * 4 * 4) + 11] = (source.position.y + np->margin[MARGIN_TOP]) * texpixel_size.y;
+								buffer[(0 * 4 * 4) + 8] = np->rect.position.x + np->rect.size.x - np->margin[MARGIN_RIGHT] * screen_scale;
+								buffer[(0 * 4 * 4) + 9] = np->rect.position.y;
 
-					buffer[(1 * 4 * 4) + 12] = np->rect.position.x + np->rect.size.x;
-					buffer[(1 * 4 * 4) + 13] = np->rect.position.y + np->margin[MARGIN_TOP] * screen_scale;
+								buffer[(0 * 4 * 4) + 10] = (source.position.x + source.size.x - np->margin[MARGIN_RIGHT]) * texpixel_size.x;
+								buffer[(0 * 4 * 4) + 11] = source.position.y * texpixel_size.y;
 
-					buffer[(1 * 4 * 4) + 14] = (source.position.x + source.size.x) * texpixel_size.x;
-					buffer[(1 * 4 * 4) + 15] = (source.position.y + np->margin[MARGIN_TOP]) * texpixel_size.y;
+								buffer[(0 * 4 * 4) + 12] = np->rect.position.x + np->rect.size.x;
+								buffer[(0 * 4 * 4) + 13] = np->rect.position.y;
 
-					// third row
+								buffer[(0 * 4 * 4) + 14] = (source.position.x + source.size.x) * texpixel_size.x;
+								buffer[(0 * 4 * 4) + 15] = source.position.y * texpixel_size.y;
 
-					buffer[(2 * 4 * 4) + 0] = np->rect.position.x;
-					buffer[(2 * 4 * 4) + 1] = np->rect.position.y + np->rect.size.y - np->margin[MARGIN_BOTTOM] * screen_scale;
+								// second row
 
-					buffer[(2 * 4 * 4) + 2] = source.position.x * texpixel_size.x;
-					buffer[(2 * 4 * 4) + 3] = (source.position.y + source.size.y - np->margin[MARGIN_BOTTOM]) * texpixel_size.y;
+								buffer[(1 * 4 * 4) + 0] = np->rect.position.x;
+								buffer[(1 * 4 * 4) + 1] = np->rect.position.y + np->margin[MARGIN_TOP] * screen_scale;
 
-					buffer[(2 * 4 * 4) + 4] = np->rect.position.x + np->margin[MARGIN_LEFT] * screen_scale;
-					buffer[(2 * 4 * 4) + 5] = np->rect.position.y + np->rect.size.y - np->margin[MARGIN_BOTTOM] * screen_scale;
+								buffer[(1 * 4 * 4) + 2] = source.position.x * texpixel_size.x;
+								buffer[(1 * 4 * 4) + 3] = (source.position.y + np->margin[MARGIN_TOP]) * texpixel_size.y;
 
-					buffer[(2 * 4 * 4) + 6] = (source.position.x + np->margin[MARGIN_LEFT]) * texpixel_size.x;
-					buffer[(2 * 4 * 4) + 7] = (source.position.y + source.size.y - np->margin[MARGIN_BOTTOM]) * texpixel_size.y;
+								buffer[(1 * 4 * 4) + 4] = np->rect.position.x + np->margin[MARGIN_LEFT] * screen_scale;
+								buffer[(1 * 4 * 4) + 5] = np->rect.position.y + np->margin[MARGIN_TOP] * screen_scale;
 
-					buffer[(2 * 4 * 4) + 8] = np->rect.position.x + np->rect.size.x - np->margin[MARGIN_RIGHT] * screen_scale;
-					buffer[(2 * 4 * 4) + 9] = np->rect.position.y + np->rect.size.y - np->margin[MARGIN_BOTTOM] * screen_scale;
+								buffer[(1 * 4 * 4) + 6] = (source.position.x + np->margin[MARGIN_LEFT]) * texpixel_size.x;
+								buffer[(1 * 4 * 4) + 7] = (source.position.y + np->margin[MARGIN_TOP]) * texpixel_size.y;
 
-					buffer[(2 * 4 * 4) + 10] = (source.position.x + source.size.x - np->margin[MARGIN_RIGHT]) * texpixel_size.x;
-					buffer[(2 * 4 * 4) + 11] = (source.position.y + source.size.y - np->margin[MARGIN_BOTTOM]) * texpixel_size.y;
+								buffer[(1 * 4 * 4) + 8] = np->rect.position.x + np->rect.size.x - np->margin[MARGIN_RIGHT] * screen_scale;
+								buffer[(1 * 4 * 4) + 9] = np->rect.position.y + np->margin[MARGIN_TOP] * screen_scale;
 
-					buffer[(2 * 4 * 4) + 12] = np->rect.position.x + np->rect.size.x;
-					buffer[(2 * 4 * 4) + 13] = np->rect.position.y + np->rect.size.y - np->margin[MARGIN_BOTTOM] * screen_scale;
+								buffer[(1 * 4 * 4) + 10] = (source.position.x + source.size.x - np->margin[MARGIN_RIGHT]) * texpixel_size.x;
+								buffer[(1 * 4 * 4) + 11] = (source.position.y + np->margin[MARGIN_TOP]) * texpixel_size.y;
 
-					buffer[(2 * 4 * 4) + 14] = (source.position.x + source.size.x) * texpixel_size.x;
-					buffer[(2 * 4 * 4) + 15] = (source.position.y + source.size.y - np->margin[MARGIN_BOTTOM]) * texpixel_size.y;
+								buffer[(1 * 4 * 4) + 12] = np->rect.position.x + np->rect.size.x;
+								buffer[(1 * 4 * 4) + 13] = np->rect.position.y + np->margin[MARGIN_TOP] * screen_scale;
 
-					// fourth row
+								buffer[(1 * 4 * 4) + 14] = (source.position.x + source.size.x) * texpixel_size.x;
+								buffer[(1 * 4 * 4) + 15] = (source.position.y + np->margin[MARGIN_TOP]) * texpixel_size.y;
 
-					buffer[(3 * 4 * 4) + 0] = np->rect.position.x;
-					buffer[(3 * 4 * 4) + 1] = np->rect.position.y + np->rect.size.y;
+								// third row
 
-					buffer[(3 * 4 * 4) + 2] = source.position.x * texpixel_size.x;
-					buffer[(3 * 4 * 4) + 3] = (source.position.y + source.size.y) * texpixel_size.y;
+								buffer[(2 * 4 * 4) + 0] = np->rect.position.x;
+								buffer[(2 * 4 * 4) + 1] = np->rect.position.y + np->rect.size.y - np->margin[MARGIN_BOTTOM] * screen_scale;
 
-					buffer[(3 * 4 * 4) + 4] = np->rect.position.x + np->margin[MARGIN_LEFT] * screen_scale;
-					buffer[(3 * 4 * 4) + 5] = np->rect.position.y + np->rect.size.y;
+								buffer[(2 * 4 * 4) + 2] = source.position.x * texpixel_size.x;
+								buffer[(2 * 4 * 4) + 3] = (source.position.y + source.size.y - np->margin[MARGIN_BOTTOM]) * texpixel_size.y;
 
-					buffer[(3 * 4 * 4) + 6] = (source.position.x + np->margin[MARGIN_LEFT]) * texpixel_size.x;
-					buffer[(3 * 4 * 4) + 7] = (source.position.y + source.size.y) * texpixel_size.y;
+								buffer[(2 * 4 * 4) + 4] = np->rect.position.x + np->margin[MARGIN_LEFT] * screen_scale;
+								buffer[(2 * 4 * 4) + 5] = np->rect.position.y + np->rect.size.y - np->margin[MARGIN_BOTTOM] * screen_scale;
 
-					buffer[(3 * 4 * 4) + 8] = np->rect.position.x + np->rect.size.x - np->margin[MARGIN_RIGHT] * screen_scale;
-					buffer[(3 * 4 * 4) + 9] = np->rect.position.y + np->rect.size.y;
+								buffer[(2 * 4 * 4) + 6] = (source.position.x + np->margin[MARGIN_LEFT]) * texpixel_size.x;
+								buffer[(2 * 4 * 4) + 7] = (source.position.y + source.size.y - np->margin[MARGIN_BOTTOM]) * texpixel_size.y;
 
-					buffer[(3 * 4 * 4) + 10] = (source.position.x + source.size.x - np->margin[MARGIN_RIGHT]) * texpixel_size.x;
-					buffer[(3 * 4 * 4) + 11] = (source.position.y + source.size.y) * texpixel_size.y;
+								buffer[(2 * 4 * 4) + 8] = np->rect.position.x + np->rect.size.x - np->margin[MARGIN_RIGHT] * screen_scale;
+								buffer[(2 * 4 * 4) + 9] = np->rect.position.y + np->rect.size.y - np->margin[MARGIN_BOTTOM] * screen_scale;
 
-					buffer[(3 * 4 * 4) + 12] = np->rect.position.x + np->rect.size.x;
-					buffer[(3 * 4 * 4) + 13] = np->rect.position.y + np->rect.size.y;
+								buffer[(2 * 4 * 4) + 10] = (source.position.x + source.size.x - np->margin[MARGIN_RIGHT]) * texpixel_size.x;
+								buffer[(2 * 4 * 4) + 11] = (source.position.y + source.size.y - np->margin[MARGIN_BOTTOM]) * texpixel_size.y;
 
-					buffer[(3 * 4 * 4) + 14] = (source.position.x + source.size.x) * texpixel_size.x;
-					buffer[(3 * 4 * 4) + 15] = (source.position.y + source.size.y) * texpixel_size.y;
-				}
+								buffer[(2 * 4 * 4) + 12] = np->rect.position.x + np->rect.size.x;
+								buffer[(2 * 4 * 4) + 13] = np->rect.position.y + np->rect.size.y - np->margin[MARGIN_BOTTOM] * screen_scale;
 
-				glBindBuffer(GL_ARRAY_BUFFER, data.ninepatch_vertices);
-				glBufferData(GL_ARRAY_BUFFER, sizeof(float) * (16 + 16) * 2, buffer, GL_DYNAMIC_DRAW);
+								buffer[(2 * 4 * 4) + 14] = (source.position.x + source.size.x) * texpixel_size.x;
+								buffer[(2 * 4 * 4) + 15] = (source.position.y + source.size.y - np->margin[MARGIN_BOTTOM]) * texpixel_size.y;
 
-				glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, data.ninepatch_elements);
+								// fourth row
 
-				glEnableVertexAttribArray(VS::ARRAY_VERTEX);
-				glEnableVertexAttribArray(VS::ARRAY_TEX_UV);
+								buffer[(3 * 4 * 4) + 0] = np->rect.position.x;
+								buffer[(3 * 4 * 4) + 1] = np->rect.position.y + np->rect.size.y;
 
-				glVertexAttribPointer(VS::ARRAY_VERTEX, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), NULL);
-				glVertexAttribPointer(VS::ARRAY_TEX_UV, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), CAST_INT_TO_UCHAR_PTR((sizeof(float) * 2)));
+								buffer[(3 * 4 * 4) + 2] = source.position.x * texpixel_size.x;
+								buffer[(3 * 4 * 4) + 3] = (source.position.y + source.size.y) * texpixel_size.y;
 
-				glDrawElements(GL_TRIANGLES, 18 * 3 - (np->draw_center ? 0 : 6), GL_UNSIGNED_BYTE, NULL);
+								buffer[(3 * 4 * 4) + 4] = np->rect.position.x + np->margin[MARGIN_LEFT] * screen_scale;
+								buffer[(3 * 4 * 4) + 5] = np->rect.position.y + np->rect.size.y;
 
-				glBindBuffer(GL_ARRAY_BUFFER, 0);
-				glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+								buffer[(3 * 4 * 4) + 6] = (source.position.x + np->margin[MARGIN_LEFT]) * texpixel_size.x;
+								buffer[(3 * 4 * 4) + 7] = (source.position.y + source.size.y) * texpixel_size.y;
 
-			} break;
+								buffer[(3 * 4 * 4) + 8] = np->rect.position.x + np->rect.size.x - np->margin[MARGIN_RIGHT] * screen_scale;
+								buffer[(3 * 4 * 4) + 9] = np->rect.position.y + np->rect.size.y;
 
-			case Item::Command::TYPE_CIRCLE: {
+								buffer[(3 * 4 * 4) + 10] = (source.position.x + source.size.x - np->margin[MARGIN_RIGHT]) * texpixel_size.x;
+								buffer[(3 * 4 * 4) + 11] = (source.position.y + source.size.y) * texpixel_size.y;
 
-				Item::CommandCircle *circle = static_cast<Item::CommandCircle *>(command);
+								buffer[(3 * 4 * 4) + 12] = np->rect.position.x + np->rect.size.x;
+								buffer[(3 * 4 * 4) + 13] = np->rect.position.y + np->rect.size.y;
 
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
+								buffer[(3 * 4 * 4) + 14] = (source.position.x + source.size.x) * texpixel_size.x;
+								buffer[(3 * 4 * 4) + 15] = (source.position.y + source.size.y) * texpixel_size.y;
+							}
 
-				if (state.canvas_shader.bind()) {
-					_set_uniforms();
-					state.canvas_shader.use_material((void *)p_material);
-				}
+							glBindBuffer(GL_ARRAY_BUFFER, data.ninepatch_vertices);
+							glBufferData(GL_ARRAY_BUFFER, sizeof(float) * (16 + 16) * 2, buffer, GL_DYNAMIC_DRAW);
 
-				static const int num_points = 32;
+							glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, data.ninepatch_elements);
 
-				Vector2 points[num_points + 1];
-				points[num_points] = circle->pos;
+							glEnableVertexAttribArray(VS::ARRAY_VERTEX);
+							glEnableVertexAttribArray(VS::ARRAY_TEX_UV);
 
-				int indices[num_points * 3];
+							glVertexAttribPointer(VS::ARRAY_VERTEX, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), NULL);
+							glVertexAttribPointer(VS::ARRAY_TEX_UV, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), CAST_INT_TO_UCHAR_PTR((sizeof(float) * 2)));
 
-				for (int j = 0; j < num_points; j++) {
-					points[j] = circle->pos + Vector2(Math::sin(j * Math_PI * 2.0 / num_points), Math::cos(j * Math_PI * 2.0 / num_points)) * circle->radius;
-					indices[j * 3 + 0] = j;
-					indices[j * 3 + 1] = (j + 1) % num_points;
-					indices[j * 3 + 2] = num_points;
-				}
+							glDrawElements(GL_TRIANGLES, 18 * 3 - (np->draw_center ? 0 : 6), GL_UNSIGNED_BYTE, NULL);
 
-				_bind_canvas_texture(RID(), RID());
+							glBindBuffer(GL_ARRAY_BUFFER, 0);
+							glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
 
-				_draw_polygon(indices, num_points * 3, num_points + 1, points, NULL, &circle->color, true);
-			} break;
+						} break;
 
-			case Item::Command::TYPE_POLYGON: {
+						case Item::Command::TYPE_CIRCLE: {
 
-				Item::CommandPolygon *polygon = static_cast<Item::CommandPolygon *>(command);
+							Item::CommandCircle *circle = static_cast<Item::CommandCircle *>(command);
 
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
+							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
 
-				if (state.canvas_shader.bind()) {
-					_set_uniforms();
-					state.canvas_shader.use_material((void *)p_material);
-				}
+							if (state.canvas_shader.bind()) {
+								_set_uniforms();
+								state.canvas_shader.use_material((void *)p_material);
+							}
 
-				RasterizerStorageGLES2::Texture *texture = _bind_canvas_texture(polygon->texture, polygon->normal_map);
+							static const int num_points = 32;
 
-				if (texture) {
-					Size2 texpixel_size(1.0 / texture->width, 1.0 / texture->height);
-					state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
-				}
+							Vector2 points[num_points + 1];
+							points[num_points] = circle->pos;
 
-				_draw_polygon(polygon->indices.ptr(), polygon->count, polygon->points.size(), polygon->points.ptr(), polygon->uvs.ptr(), polygon->colors.ptr(), polygon->colors.size() == 1, polygon->weights.ptr(), polygon->bones.ptr());
-#ifdef GLES_OVER_GL
-				if (polygon->antialiased) {
-					glEnable(GL_LINE_SMOOTH);
-					if (polygon->antialiasing_use_indices) {
-						_draw_generic_indices(GL_LINE_STRIP, polygon->indices.ptr(), polygon->count, polygon->points.size(), polygon->points.ptr(), polygon->uvs.ptr(), polygon->colors.ptr(), polygon->colors.size() == 1);
-					} else {
-						_draw_generic(GL_LINE_LOOP, polygon->points.size(), polygon->points.ptr(), polygon->uvs.ptr(), polygon->colors.ptr(), polygon->colors.size() == 1);
-					}
-					glDisable(GL_LINE_SMOOTH);
-				}
-#endif
-			} break;
-			case Item::Command::TYPE_MESH: {
+							int indices[num_points * 3];
 
-				Item::CommandMesh *mesh = static_cast<Item::CommandMesh *>(command);
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
+							for (int j = 0; j < num_points; j++) {
+								points[j] = circle->pos + Vector2(Math::sin(j * Math_PI * 2.0 / num_points), Math::cos(j * Math_PI * 2.0 / num_points)) * circle->radius;
+								indices[j * 3 + 0] = j;
+								indices[j * 3 + 1] = (j + 1) % num_points;
+								indices[j * 3 + 2] = num_points;
+							}
 
-				if (state.canvas_shader.bind()) {
-					_set_uniforms();
-					state.canvas_shader.use_material((void *)p_material);
-				}
+							_bind_canvas_texture(RID(), RID());
 
-				RasterizerStorageGLES2::Texture *texture = _bind_canvas_texture(mesh->texture, mesh->normal_map);
+							_draw_polygon(indices, num_points * 3, num_points + 1, points, NULL, &circle->color, true);
+						} break;
 
-				if (texture) {
-					Size2 texpixel_size(1.0 / texture->width, 1.0 / texture->height);
-					state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
-				}
+						case Item::Command::TYPE_POLYGON: {
 
-				RasterizerStorageGLES2::Mesh *mesh_data = storage->mesh_owner.getornull(mesh->mesh);
-				if (mesh_data) {
+							Item::CommandPolygon *polygon = static_cast<Item::CommandPolygon *>(command);
 
-					for (int j = 0; j < mesh_data->surfaces.size(); j++) {
-						RasterizerStorageGLES2::Surface *s = mesh_data->surfaces[j];
-						// materials are ignored in 2D meshes, could be added but many things (ie, lighting mode, reading from screen, etc) would break as they are not meant be set up at this point of drawing
+							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
 
-						glBindBuffer(GL_ARRAY_BUFFER, s->vertex_id);
+							if (state.canvas_shader.bind()) {
+								_set_uniforms();
+								state.canvas_shader.use_material((void *)p_material);
+							}
 
-						if (s->index_array_len > 0) {
-							glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, s->index_id);
-						}
+							RasterizerStorageGLES2::Texture *texture = _bind_canvas_texture(polygon->texture, polygon->normal_map);
 
-						for (int k = 0; k < VS::ARRAY_MAX - 1; k++) {
-							if (s->attribs[k].enabled) {
-								glEnableVertexAttribArray(k);
-								glVertexAttribPointer(s->attribs[k].index, s->attribs[k].size, s->attribs[k].type, s->attribs[k].normalized, s->attribs[k].stride, CAST_INT_TO_UCHAR_PTR(s->attribs[k].offset));
-							} else {
-								glDisableVertexAttribArray(k);
-								switch (k) {
-									case VS::ARRAY_NORMAL: {
-										glVertexAttrib4f(VS::ARRAY_NORMAL, 0.0, 0.0, 1, 1);
-									} break;
-									case VS::ARRAY_COLOR: {
-										glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
-
-									} break;
-									default: {
-									}
-								}
+							if (texture) {
+								Size2 texpixel_size(1.0 / texture->width, 1.0 / texture->height);
+								state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
 							}
-						}
 
-						if (s->index_array_len > 0) {
-							glDrawElements(gl_primitive[s->primitive], s->index_array_len, (s->array_len >= (1 << 16)) ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT, 0);
-						} else {
-							glDrawArrays(gl_primitive[s->primitive], 0, s->array_len);
-						}
-					}
-
-					for (int j = 1; j < VS::ARRAY_MAX - 1; j++) {
-						glDisableVertexAttribArray(j);
-					}
-				}
+							_draw_polygon(polygon->indices.ptr(), polygon->count, polygon->points.size(), polygon->points.ptr(), polygon->uvs.ptr(), polygon->colors.ptr(), polygon->colors.size() == 1, polygon->weights.ptr(), polygon->bones.ptr());
+#ifdef GLES_OVER_GL
+							if (polygon->antialiased) {
+								glEnable(GL_LINE_SMOOTH);
+								if (polygon->antialiasing_use_indices) {
+									_draw_generic_indices(GL_LINE_STRIP, polygon->indices.ptr(), polygon->count, polygon->points.size(), polygon->points.ptr(), polygon->uvs.ptr(), polygon->colors.ptr(), polygon->colors.size() == 1);
+								} else {
+									_draw_generic(GL_LINE_LOOP, polygon->points.size(), polygon->points.ptr(), polygon->uvs.ptr(), polygon->colors.ptr(), polygon->colors.size() == 1);
+								}
+								glDisable(GL_LINE_SMOOTH);
+							}
+#endif
+						} break;
+						case Item::Command::TYPE_MESH: {
 
-			} break;
-			case Item::Command::TYPE_MULTIMESH: {
-				Item::CommandMultiMesh *mmesh = static_cast<Item::CommandMultiMesh *>(command);
+							Item::CommandMesh *mesh = static_cast<Item::CommandMesh *>(command);
+							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
 
-				RasterizerStorageGLES2::MultiMesh *multi_mesh = storage->multimesh_owner.getornull(mmesh->multimesh);
+							if (state.canvas_shader.bind()) {
+								_set_uniforms();
+								state.canvas_shader.use_material((void *)p_material);
+							}
 
-				if (!multi_mesh)
-					break;
+							RasterizerStorageGLES2::Texture *texture = _bind_canvas_texture(mesh->texture, mesh->normal_map);
 
-				RasterizerStorageGLES2::Mesh *mesh_data = storage->mesh_owner.getornull(multi_mesh->mesh);
+							if (texture) {
+								Size2 texpixel_size(1.0 / texture->width, 1.0 / texture->height);
+								state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
+							}
 
-				if (!mesh_data)
-					break;
+							RasterizerStorageGLES2::Mesh *mesh_data = storage->mesh_owner.getornull(mesh->mesh);
+							if (mesh_data) {
 
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_INSTANCE_CUSTOM, multi_mesh->custom_data_format != VS::MULTIMESH_CUSTOM_DATA_NONE);
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_INSTANCING, true);
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
+								for (int j = 0; j < mesh_data->surfaces.size(); j++) {
+									RasterizerStorageGLES2::Surface *s = mesh_data->surfaces[j];
+									// materials are ignored in 2D meshes, could be added but many things (ie, lighting mode, reading from screen, etc) would break as they are not meant be set up at this point of drawing
 
-				if (state.canvas_shader.bind()) {
-					_set_uniforms();
-					state.canvas_shader.use_material((void *)p_material);
-				}
+									glBindBuffer(GL_ARRAY_BUFFER, s->vertex_id);
 
-				RasterizerStorageGLES2::Texture *texture = _bind_canvas_texture(mmesh->texture, mmesh->normal_map);
+									if (s->index_array_len > 0) {
+										glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, s->index_id);
+									}
 
-				if (texture) {
-					Size2 texpixel_size(1.0 / texture->width, 1.0 / texture->height);
-					state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
-				}
+									for (int k = 0; k < VS::ARRAY_MAX - 1; k++) {
+										if (s->attribs[k].enabled) {
+											glEnableVertexAttribArray(k);
+											glVertexAttribPointer(s->attribs[k].index, s->attribs[k].size, s->attribs[k].type, s->attribs[k].normalized, s->attribs[k].stride, CAST_INT_TO_UCHAR_PTR(s->attribs[k].offset));
+										} else {
+											glDisableVertexAttribArray(k);
+											switch (k) {
+												case VS::ARRAY_NORMAL: {
+													glVertexAttrib4f(VS::ARRAY_NORMAL, 0.0, 0.0, 1, 1);
+												} break;
+												case VS::ARRAY_COLOR: {
+													glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
+
+												} break;
+												default: {
+												}
+											}
+										}
+									}
 
-				//reset shader and force rebind
+									if (s->index_array_len > 0) {
+										glDrawElements(gl_primitive[s->primitive], s->index_array_len, (s->array_len >= (1 << 16)) ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT, 0);
+									} else {
+										glDrawArrays(gl_primitive[s->primitive], 0, s->array_len);
+									}
+								}
 
-				int amount = MIN(multi_mesh->size, multi_mesh->visible_instances);
+								for (int j = 1; j < VS::ARRAY_MAX - 1; j++) {
+									glDisableVertexAttribArray(j);
+								}
+							}
 
-				if (amount == -1) {
-					amount = multi_mesh->size;
-				}
+						} break;
+						case Item::Command::TYPE_MULTIMESH: {
+							Item::CommandMultiMesh *mmesh = static_cast<Item::CommandMultiMesh *>(command);
 
-				int stride = multi_mesh->color_floats + multi_mesh->custom_data_floats + multi_mesh->xform_floats;
+							RasterizerStorageGLES2::MultiMesh *multi_mesh = storage->multimesh_owner.getornull(mmesh->multimesh);
 
-				int color_ofs = multi_mesh->xform_floats;
-				int custom_data_ofs = color_ofs + multi_mesh->color_floats;
+							if (!multi_mesh)
+								break;
 
-				// drawing
+							RasterizerStorageGLES2::Mesh *mesh_data = storage->mesh_owner.getornull(multi_mesh->mesh);
 
-				const float *base_buffer = multi_mesh->data.ptr();
+							if (!mesh_data)
+								break;
 
-				for (int j = 0; j < mesh_data->surfaces.size(); j++) {
-					RasterizerStorageGLES2::Surface *s = mesh_data->surfaces[j];
-					// materials are ignored in 2D meshes, could be added but many things (ie, lighting mode, reading from screen, etc) would break as they are not meant be set up at this point of drawing
+							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_INSTANCE_CUSTOM, multi_mesh->custom_data_format != VS::MULTIMESH_CUSTOM_DATA_NONE);
+							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_INSTANCING, true);
+							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
 
-					//bind buffers for mesh surface
-					glBindBuffer(GL_ARRAY_BUFFER, s->vertex_id);
+							if (state.canvas_shader.bind()) {
+								_set_uniforms();
+								state.canvas_shader.use_material((void *)p_material);
+							}
 
-					if (s->index_array_len > 0) {
-						glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, s->index_id);
-					}
+							RasterizerStorageGLES2::Texture *texture = _bind_canvas_texture(mmesh->texture, mmesh->normal_map);
 
-					for (int k = 0; k < VS::ARRAY_MAX - 1; k++) {
-						if (s->attribs[k].enabled) {
-							glEnableVertexAttribArray(k);
-							glVertexAttribPointer(s->attribs[k].index, s->attribs[k].size, s->attribs[k].type, s->attribs[k].normalized, s->attribs[k].stride, CAST_INT_TO_UCHAR_PTR(s->attribs[k].offset));
-						} else {
-							glDisableVertexAttribArray(k);
-							switch (k) {
-								case VS::ARRAY_NORMAL: {
-									glVertexAttrib4f(VS::ARRAY_NORMAL, 0.0, 0.0, 1, 1);
-								} break;
-								case VS::ARRAY_COLOR: {
-									glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
-
-								} break;
-								default: {
-								}
+							if (texture) {
+								Size2 texpixel_size(1.0 / texture->width, 1.0 / texture->height);
+								state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
 							}
-						}
-					}
 
-					for (int k = 0; k < amount; k++) {
-						const float *buffer = base_buffer + k * stride;
+							//reset shader and force rebind
 
-						{
+							int amount = MIN(multi_mesh->size, multi_mesh->visible_instances);
 
-							glVertexAttrib4fv(INSTANCE_ATTRIB_BASE + 0, &buffer[0]);
-							glVertexAttrib4fv(INSTANCE_ATTRIB_BASE + 1, &buffer[4]);
-							if (multi_mesh->transform_format == VS::MULTIMESH_TRANSFORM_3D) {
-								glVertexAttrib4fv(INSTANCE_ATTRIB_BASE + 2, &buffer[8]);
-							} else {
-								glVertexAttrib4f(INSTANCE_ATTRIB_BASE + 2, 0.0, 0.0, 1.0, 0.0);
+							if (amount == -1) {
+								amount = multi_mesh->size;
 							}
-						}
 
-						if (multi_mesh->color_floats) {
-							if (multi_mesh->color_format == VS::MULTIMESH_COLOR_8BIT) {
-								uint8_t *color_data = (uint8_t *)(buffer + color_ofs);
-								glVertexAttrib4f(INSTANCE_ATTRIB_BASE + 3, color_data[0] / 255.0, color_data[1] / 255.0, color_data[2] / 255.0, color_data[3] / 255.0);
-							} else {
-								glVertexAttrib4fv(INSTANCE_ATTRIB_BASE + 3, buffer + color_ofs);
-							}
-						} else {
-							glVertexAttrib4f(INSTANCE_ATTRIB_BASE + 3, 1.0, 1.0, 1.0, 1.0);
-						}
-
-						if (multi_mesh->custom_data_floats) {
-							if (multi_mesh->custom_data_format == VS::MULTIMESH_CUSTOM_DATA_8BIT) {
-								uint8_t *custom_data = (uint8_t *)(buffer + custom_data_ofs);
-								glVertexAttrib4f(INSTANCE_ATTRIB_BASE + 4, custom_data[0] / 255.0, custom_data[1] / 255.0, custom_data[2] / 255.0, custom_data[3] / 255.0);
-							} else {
-								glVertexAttrib4fv(INSTANCE_ATTRIB_BASE + 4, buffer + custom_data_ofs);
-							}
-						}
+							int stride = multi_mesh->color_floats + multi_mesh->custom_data_floats + multi_mesh->xform_floats;
 
-						if (s->index_array_len > 0) {
-							glDrawElements(gl_primitive[s->primitive], s->index_array_len, (s->array_len >= (1 << 16)) ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT, 0);
-						} else {
-							glDrawArrays(gl_primitive[s->primitive], 0, s->array_len);
-						}
-					}
-				}
+							int color_ofs = multi_mesh->xform_floats;
+							int custom_data_ofs = color_ofs + multi_mesh->color_floats;
 
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_INSTANCE_CUSTOM, false);
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_INSTANCING, false);
+							// drawing
 
-			} break;
-			case Item::Command::TYPE_POLYLINE: {
-				Item::CommandPolyLine *pline = static_cast<Item::CommandPolyLine *>(command);
+							const float *base_buffer = multi_mesh->data.ptr();
 
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
+							for (int j = 0; j < mesh_data->surfaces.size(); j++) {
+								RasterizerStorageGLES2::Surface *s = mesh_data->surfaces[j];
+								// materials are ignored in 2D meshes, could be added but many things (ie, lighting mode, reading from screen, etc) would break as they are not meant be set up at this point of drawing
 
-				if (state.canvas_shader.bind()) {
-					_set_uniforms();
-					state.canvas_shader.use_material((void *)p_material);
-				}
+								//bind buffers for mesh surface
+								glBindBuffer(GL_ARRAY_BUFFER, s->vertex_id);
+
+								if (s->index_array_len > 0) {
+									glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, s->index_id);
+								}
+
+								for (int k = 0; k < VS::ARRAY_MAX - 1; k++) {
+									if (s->attribs[k].enabled) {
+										glEnableVertexAttribArray(k);
+										glVertexAttribPointer(s->attribs[k].index, s->attribs[k].size, s->attribs[k].type, s->attribs[k].normalized, s->attribs[k].stride, CAST_INT_TO_UCHAR_PTR(s->attribs[k].offset));
+									} else {
+										glDisableVertexAttribArray(k);
+										switch (k) {
+											case VS::ARRAY_NORMAL: {
+												glVertexAttrib4f(VS::ARRAY_NORMAL, 0.0, 0.0, 1, 1);
+											} break;
+											case VS::ARRAY_COLOR: {
+												glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
+
+											} break;
+											default: {
+											}
+										}
+									}
+								}
+
+								for (int k = 0; k < amount; k++) {
+									const float *buffer = base_buffer + k * stride;
+
+									{
+
+										glVertexAttrib4fv(INSTANCE_ATTRIB_BASE + 0, &buffer[0]);
+										glVertexAttrib4fv(INSTANCE_ATTRIB_BASE + 1, &buffer[4]);
+										if (multi_mesh->transform_format == VS::MULTIMESH_TRANSFORM_3D) {
+											glVertexAttrib4fv(INSTANCE_ATTRIB_BASE + 2, &buffer[8]);
+										} else {
+											glVertexAttrib4f(INSTANCE_ATTRIB_BASE + 2, 0.0, 0.0, 1.0, 0.0);
+										}
+									}
 
-				_bind_canvas_texture(RID(), RID());
+									if (multi_mesh->color_floats) {
+										if (multi_mesh->color_format == VS::MULTIMESH_COLOR_8BIT) {
+											uint8_t *color_data = (uint8_t *)(buffer + color_ofs);
+											glVertexAttrib4f(INSTANCE_ATTRIB_BASE + 3, color_data[0] / 255.0, color_data[1] / 255.0, color_data[2] / 255.0, color_data[3] / 255.0);
+										} else {
+											glVertexAttrib4fv(INSTANCE_ATTRIB_BASE + 3, buffer + color_ofs);
+										}
+									} else {
+										glVertexAttrib4f(INSTANCE_ATTRIB_BASE + 3, 1.0, 1.0, 1.0, 1.0);
+									}
+
+									if (multi_mesh->custom_data_floats) {
+										if (multi_mesh->custom_data_format == VS::MULTIMESH_CUSTOM_DATA_8BIT) {
+											uint8_t *custom_data = (uint8_t *)(buffer + custom_data_ofs);
+											glVertexAttrib4f(INSTANCE_ATTRIB_BASE + 4, custom_data[0] / 255.0, custom_data[1] / 255.0, custom_data[2] / 255.0, custom_data[3] / 255.0);
+										} else {
+											glVertexAttrib4fv(INSTANCE_ATTRIB_BASE + 4, buffer + custom_data_ofs);
+										}
+									}
+
+									if (s->index_array_len > 0) {
+										glDrawElements(gl_primitive[s->primitive], s->index_array_len, (s->array_len >= (1 << 16)) ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT, 0);
+									} else {
+										glDrawArrays(gl_primitive[s->primitive], 0, s->array_len);
+									}
+								}
+							}
 
-				if (pline->triangles.size()) {
-					_draw_generic(GL_TRIANGLE_STRIP, pline->triangles.size(), pline->triangles.ptr(), NULL, pline->triangle_colors.ptr(), pline->triangle_colors.size() == 1);
+							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_INSTANCE_CUSTOM, false);
+							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_INSTANCING, false);
+
+						} break;
+						case Item::Command::TYPE_POLYLINE: {
+							Item::CommandPolyLine *pline = static_cast<Item::CommandPolyLine *>(command);
+
+							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
+
+							if (state.canvas_shader.bind()) {
+								_set_uniforms();
+								state.canvas_shader.use_material((void *)p_material);
+							}
+
+							_bind_canvas_texture(RID(), RID());
+
+							if (pline->triangles.size()) {
+								_draw_generic(GL_TRIANGLE_STRIP, pline->triangles.size(), pline->triangles.ptr(), NULL, pline->triangle_colors.ptr(), pline->triangle_colors.size() == 1);
 #ifdef GLES_OVER_GL
-					glEnable(GL_LINE_SMOOTH);
-					if (pline->multiline) {
-						//needs to be different
-					} else {
-						_draw_generic(GL_LINE_LOOP, pline->lines.size(), pline->lines.ptr(), NULL, pline->line_colors.ptr(), pline->line_colors.size() == 1);
-					}
-					glDisable(GL_LINE_SMOOTH);
+								glEnable(GL_LINE_SMOOTH);
+								if (pline->multiline) {
+									//needs to be different
+								} else {
+									_draw_generic(GL_LINE_LOOP, pline->lines.size(), pline->lines.ptr(), NULL, pline->line_colors.ptr(), pline->line_colors.size() == 1);
+								}
+								glDisable(GL_LINE_SMOOTH);
 #endif
-				} else {
+							} else {
 
 #ifdef GLES_OVER_GL
-					if (pline->antialiased)
-						glEnable(GL_LINE_SMOOTH);
+								if (pline->antialiased)
+									glEnable(GL_LINE_SMOOTH);
 #endif
 
-					if (pline->multiline) {
-						int todo = pline->lines.size() / 2;
-						int max_per_call = data.polygon_buffer_size / (sizeof(real_t) * 4);
-						int offset = 0;
-
-						while (todo) {
-							int to_draw = MIN(max_per_call, todo);
-							_draw_generic(GL_LINES, to_draw * 2, &pline->lines.ptr()[offset], NULL, pline->line_colors.size() == 1 ? pline->line_colors.ptr() : &pline->line_colors.ptr()[offset], pline->line_colors.size() == 1);
-							todo -= to_draw;
-							offset += to_draw * 2;
-						}
-					} else {
-						_draw_generic(GL_LINES, pline->lines.size(), pline->lines.ptr(), NULL, pline->line_colors.ptr(), pline->line_colors.size() == 1);
-					}
+								if (pline->multiline) {
+									int todo = pline->lines.size() / 2;
+									int max_per_call = data.polygon_buffer_size / (sizeof(real_t) * 4);
+									int offset = 0;
+
+									while (todo) {
+										int to_draw = MIN(max_per_call, todo);
+										_draw_generic(GL_LINES, to_draw * 2, &pline->lines.ptr()[offset], NULL, pline->line_colors.size() == 1 ? pline->line_colors.ptr() : &pline->line_colors.ptr()[offset], pline->line_colors.size() == 1);
+										todo -= to_draw;
+										offset += to_draw * 2;
+									}
+								} else {
+									_draw_generic(GL_LINES, pline->lines.size(), pline->lines.ptr(), NULL, pline->line_colors.ptr(), pline->line_colors.size() == 1);
+								}
 
 #ifdef GLES_OVER_GL
-					if (pline->antialiased)
-						glDisable(GL_LINE_SMOOTH);
+								if (pline->antialiased)
+									glDisable(GL_LINE_SMOOTH);
 #endif
-				}
-			} break;
+							}
+						} break;
 
-			case Item::Command::TYPE_PRIMITIVE: {
+						case Item::Command::TYPE_PRIMITIVE: {
 
-				Item::CommandPrimitive *primitive = static_cast<Item::CommandPrimitive *>(command);
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
+							Item::CommandPrimitive *primitive = static_cast<Item::CommandPrimitive *>(command);
+							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, false);
 
-				if (state.canvas_shader.bind()) {
-					_set_uniforms();
-					state.canvas_shader.use_material((void *)p_material);
-				}
+							if (state.canvas_shader.bind()) {
+								_set_uniforms();
+								state.canvas_shader.use_material((void *)p_material);
+							}
 
-				ERR_CONTINUE(primitive->points.size() < 1);
+							ERR_CONTINUE(primitive->points.size() < 1);
 
-				RasterizerStorageGLES2::Texture *texture = _bind_canvas_texture(primitive->texture, primitive->normal_map);
+							RasterizerStorageGLES2::Texture *texture = _bind_canvas_texture(primitive->texture, primitive->normal_map);
 
-				if (texture) {
-					Size2 texpixel_size(1.0 / texture->width, 1.0 / texture->height);
-					state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
-				}
+							if (texture) {
+								Size2 texpixel_size(1.0 / texture->width, 1.0 / texture->height);
+								state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
+							}
 
-				if (primitive->colors.size() == 1 && primitive->points.size() > 1) {
-					Color c = primitive->colors[0];
-					glVertexAttrib4f(VS::ARRAY_COLOR, c.r, c.g, c.b, c.a);
-				} else if (primitive->colors.empty()) {
-					glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
-				}
+							if (primitive->colors.size() == 1 && primitive->points.size() > 1) {
+								Color c = primitive->colors[0];
+								glVertexAttrib4f(VS::ARRAY_COLOR, c.r, c.g, c.b, c.a);
+							} else if (primitive->colors.empty()) {
+								glVertexAttrib4f(VS::ARRAY_COLOR, 1, 1, 1, 1);
+							}
 
-				_draw_gui_primitive(primitive->points.size(), primitive->points.ptr(), primitive->colors.ptr(), primitive->uvs.ptr());
-			} break;
+							_draw_gui_primitive(primitive->points.size(), primitive->points.ptr(), primitive->colors.ptr(), primitive->uvs.ptr());
+						} break;
 
-			case Item::Command::TYPE_TRANSFORM: {
-				Item::CommandTransform *transform = static_cast<Item::CommandTransform *>(command);
-				state.uniforms.extra_matrix = transform->xform;
-				state.canvas_shader.set_uniform(CanvasShaderGLES2::EXTRA_MATRIX, state.uniforms.extra_matrix);
-			} break;
+						case Item::Command::TYPE_TRANSFORM: {
+							Item::CommandTransform *transform = static_cast<Item::CommandTransform *>(command);
+							state.uniforms.extra_matrix = transform->xform;
+							state.canvas_shader.set_uniform(CanvasShaderGLES2::EXTRA_MATRIX, state.uniforms.extra_matrix);
+						} break;
 
-			case Item::Command::TYPE_PARTICLES: {
+						case Item::Command::TYPE_PARTICLES: {
 
-			} break;
+						} break;
+
+						case Item::Command::TYPE_CLIP_IGNORE: {
+
+							Item::CommandClipIgnore *ci = static_cast<Item::CommandClipIgnore *>(command);
+							if (current_clip) {
+								if (ci->ignore != reclip) {
+									if (ci->ignore) {
+										glDisable(GL_SCISSOR_TEST);
+										reclip = true;
+									} else {
+										glEnable(GL_SCISSOR_TEST);
 
-			case Item::Command::TYPE_CLIP_IGNORE: {
+										int x = current_clip->final_clip_rect.position.x;
+										int y = storage->frame.current_rt->height - (current_clip->final_clip_rect.position.y + current_clip->final_clip_rect.size.y);
+										int w = current_clip->final_clip_rect.size.x;
+										int h = current_clip->final_clip_rect.size.y;
 
-				Item::CommandClipIgnore *ci = static_cast<Item::CommandClipIgnore *>(command);
-				if (current_clip) {
-					if (ci->ignore != reclip) {
-						if (ci->ignore) {
-							glDisable(GL_SCISSOR_TEST);
-							reclip = true;
-						} else {
-							glEnable(GL_SCISSOR_TEST);
+										if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_VFLIP])
+											y = current_clip->final_clip_rect.position.y;
 
-							int x = current_clip->final_clip_rect.position.x;
-							int y = storage->frame.current_rt->height - (current_clip->final_clip_rect.position.y + current_clip->final_clip_rect.size.y);
-							int w = current_clip->final_clip_rect.size.x;
-							int h = current_clip->final_clip_rect.size.y;
+										glScissor(x, y, w, h);
 
-							if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_VFLIP])
-								y = current_clip->final_clip_rect.position.y;
+										reclip = false;
+									}
+								}
+							}
 
-							glScissor(x, y, w, h);
+						} break;
 
-							reclip = false;
-						}
+						default: {
+							// FIXME: Proper error handling if relevant
+							//print_line("other");
+						} break;
 					}
 				}
 
-			} break;
-
-			default: {
-				// FIXME: Proper error handling if relevant
-				//print_line("other");
-			} break;
+			} // default
+			break;
 		}
 	}
+
+	// zero all the batch data ready for a new run
+	bdata.reset_flush();
 }
 
-void RasterizerCanvasGLES2::_copy_screen(const Rect2 &p_rect) {
+void RasterizerCanvasGLES2::render_joined_item_commands(const BItemJoined &bij, Item *current_clip, bool &reclip, RasterizerStorageGLES2::Material *p_material) {
 
-	if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_DIRECT_TO_SCREEN]) {
-		ERR_PRINT_ONCE("Cannot use screen texture copying in render target set to render direct to screen.");
-		return;
+	Item *item = 0;
+
+	FillState fill_state;
+	fill_state.reset();
+	fill_state.use_hardware_transform = bij.use_hardware_transform();
+
+	for (unsigned int i = 0; i < bij.num_item_refs; i++) {
+		item = bdata.item_refs[bij.first_item_ref + i].m_pItem;
+
+		int command_count = item->commands.size();
+		int command_start = 0;
+
+		while (command_start < command_count) {
+			// fill as many batches as possible (until all done, or the vertex buffer is full)
+			bool bFull = prefill_joined_item(fill_state, command_start, item, current_clip, reclip, p_material);
+
+			if (bFull) {
+				// flush
+				flush_render_batches(item, current_clip, reclip, p_material);
+				fill_state.reset();
+			}
+		}
 	}
 
-	ERR_FAIL_COND_MSG(storage->frame.current_rt->copy_screen_effect.color == 0, "Can't use screen texture copying in a render target configured without copy buffers.");
+	// flush if any left
+	if (item) {
+		// always pass first item
+		item = bdata.item_refs[bij.first_item_ref].m_pItem;
 
-	glDisable(GL_BLEND);
+		flush_render_batches(item, current_clip, reclip, p_material);
+	}
+}
 
-	Vector2 wh(storage->frame.current_rt->width, storage->frame.current_rt->height);
+void RasterizerCanvasGLES2::flush_render_batches(Item *p_item, Item *current_clip, bool &reclip, RasterizerStorageGLES2::Material *p_material) {
+	//print_line("_flush_render_batches");
 
-	Color copy_section(p_rect.position.x / wh.x, p_rect.position.y / wh.y, p_rect.size.x / wh.x, p_rect.size.y / wh.y);
+	// some heuristic to decide whether to use colored verts.
+	// feel free to tweak this.
+	// this could use hysteresis, to prevent jumping between methods
+	// .. however probably not necessary
+	if ((bdata.total_color_changes * 4) > (bdata.total_quads * 3)) {
+		bdata.use_colored_vertices = true;
 
-	if (p_rect != Rect2()) {
-		storage->shaders.copy.set_conditional(CopyShaderGLES2::USE_COPY_SECTION, true);
+		// small perf cost versus going straight to colored verts (maybe around 10%)
+		// however more straightforward
+		_batch_translate_to_colored();
+	} else {
+		bdata.use_colored_vertices = false;
 	}
 
-	storage->shaders.copy.set_conditional(CopyShaderGLES2::USE_NO_ALPHA, !state.using_transparent_rt);
+	// send buffers to opengl
+	_batch_upload_buffers();
 
-	glBindFramebuffer(GL_FRAMEBUFFER, storage->frame.current_rt->copy_screen_effect.fbo);
-	glActiveTexture(GL_TEXTURE0);
-	glBindTexture(GL_TEXTURE_2D, storage->frame.current_rt->color);
+	Item::Command *const *commands = p_item->commands.ptr();
+	//int s = p_item->commands.size();
 
-	storage->shaders.copy.bind();
-	storage->shaders.copy.set_uniform(CopyShaderGLES2::COPY_SECTION, copy_section);
+	render_batches(commands, 0, current_clip, reclip, p_material);
+}
 
-	const Vector2 vertpos[4] = {
-		Vector2(-1, -1),
-		Vector2(-1, 1),
-		Vector2(1, 1),
-		Vector2(1, -1),
-	};
+void RasterizerCanvasGLES2::_canvas_item_render_commands(Item *p_item, Item *current_clip, bool &reclip, RasterizerStorageGLES2::Material *p_material) {
 
-	const Vector2 uvpos[4] = {
-		Vector2(0, 0),
-		Vector2(0, 1),
-		Vector2(1, 1),
-		Vector2(1, 0)
-	};
+	int command_count = p_item->commands.size();
+	int command_start = 0;
 
-	const int indexpos[6] = {
-		0, 1, 2,
-		2, 3, 0
-	};
+	Item::Command *const *commands = p_item->commands.ptr();
 
-	_draw_polygon(indexpos, 6, 4, vertpos, uvpos, NULL, false);
+	// while there are still more batches to fill...
+	// we may have to do this multiple times because there is a limit of 65535
+	// verts referenced in the index buffer (each potential run of this loop)
+	while (command_start < command_count) {
+		{
+			// legacy .. just create one massive batch and render everything as before
+			bdata.batches.reset();
+			Batch *batch = _batch_request_new();
+			batch->type = Batch::BT_DEFAULT;
+			batch->num_commands = command_count;
+
+			// signify to do only one while loop
+			command_start = command_count;
+		}
 
-	storage->shaders.copy.set_conditional(CopyShaderGLES2::USE_COPY_SECTION, false);
-	storage->shaders.copy.set_conditional(CopyShaderGLES2::USE_NO_ALPHA, false);
+		render_batches(commands, 0, current_clip, reclip, p_material);
 
-	glBindFramebuffer(GL_FRAMEBUFFER, storage->frame.current_rt->fbo); //back to front
-	glEnable(GL_BLEND);
+	} // while there are still more batches to fill
 }
 
-void RasterizerCanvasGLES2::_copy_texscreen(const Rect2 &p_rect) {
+void RasterizerCanvasGLES2::join_items(Item *p_item_list, int p_z, const Color &p_modulate, Light *p_light, const Transform2D &p_base_transform) {
+	bdata.items_joined.reset();
+	bdata.item_refs.reset();
 
-	state.canvas_texscreen_used = true;
+	RIState ris;
+	ris.IG_z = p_z;
+	ris.IG_modulate = p_modulate;
+	ris.IG_light = p_light;
+	ris.IG_base_transform = p_base_transform;
 
-	_copy_screen(p_rect);
+	BItemJoined *j = 0;
 
-	// back to canvas, force rebind
-	state.using_texture_rect = false;
-	state.canvas_shader.bind();
-	_bind_canvas_texture(state.current_tex, state.current_normal);
-	_set_uniforms();
+	bool batch_break = false;
+
+	while (p_item_list) {
+
+		Item *ci = p_item_list;
+
+		bool join;
+
+		if (batch_break) {
+			// always start a new batch
+			join = false;
+
+			// could be another batch break?
+			try_join_item(ci, ris, batch_break);
+			//batch_break = false;
+		} else {
+			join = try_join_item(ci, ris, batch_break);
+		}
+
+		// assume the first item will always return no join
+		if (!join) {
+			j = bdata.items_joined.request_with_grow();
+			j->first_item_ref = bdata.item_refs.size();
+			j->num_item_refs = 1;
+			j->bounding_rect = ci->global_rect_cache;
+
+			// add the reference
+			BItemRef *r = bdata.item_refs.request_with_grow();
+			r->m_pItem = ci;
+		} else {
+			CRASH_COND(j == 0);
+			j->num_item_refs += 1;
+			j->bounding_rect = j->bounding_rect.merge(ci->global_rect_cache);
+
+			BItemRef *r = bdata.item_refs.request_with_grow();
+			r->m_pItem = ci;
+		}
+
+		p_item_list = p_item_list->next;
+	}
 }
 
 void RasterizerCanvasGLES2::canvas_render_items(Item *p_item_list, int p_z, const Color &p_modulate, Light *p_light, const Transform2D &p_base_transform) {
 
-	Item *current_clip = NULL;
+	// if we are debugging, flash each frame between batching renderer and old version to compare for regressions
+#ifdef KESSEL_FLASH
+	if ((Engine::get_singleton()->get_frames_drawn() % 2) == 0)
+		bdata.use_batching = true;
+	else
+		bdata.use_batching = false;
+#endif
+
+	// state 1 : join similar items, so that their state changes are not repeated,
+	// and commands from joined items can be batched together
+	if (bdata.use_batching)
+		join_items(p_item_list, p_z, p_modulate, p_light, p_base_transform);
 
-	RasterizerStorageGLES2::Shader *shader_cache = NULL;
+	canvas_render_items_implementation(p_item_list, p_z, p_modulate, p_light, p_base_transform);
+}
+
+void RasterizerCanvasGLES2::canvas_render_items_implementation(Item *p_item_list, int p_z, const Color &p_modulate, Light *p_light, const Transform2D &p_base_transform) {
+
+	// parameters are easier to pass around in a structure
+	RIState ris;
+	ris.IG_z = p_z;
+	ris.IG_modulate = p_modulate;
+	ris.IG_light = p_light;
+	ris.IG_base_transform = p_base_transform;
 
-	bool rebind_shader = true;
-	bool prev_use_skeleton = false;
 	state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SKELETON, false);
 
 	state.current_tex = RID();
@@ -1442,787 +1571,1118 @@ void RasterizerCanvasGLES2::canvas_render_items(Item *p_item_list, int p_z, cons
 	glActiveTexture(GL_TEXTURE0);
 	glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
 
-	int last_blend_mode = -1;
+	if (bdata.use_batching) {
+		for (int j = 0; j < bdata.items_joined.size(); j++) {
+			render_joined_item(bdata.items_joined[j], ris);
+		}
+	} else {
+		while (p_item_list) {
+
+			Item *ci = p_item_list;
+			_canvas_render_item(ci, ris);
+			p_item_list = p_item_list->next;
+		}
+	}
 
-	RID canvas_last_material = RID();
+	if (ris.current_clip) {
+		glDisable(GL_SCISSOR_TEST);
+	}
 
-	while (p_item_list) {
+	state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SKELETON, false);
+}
 
-		Item *ci = p_item_list;
+// This function is a dry run of the state changes when drawing the item.
+// It should duplicate the logic in _canvas_render_item,
+// to decide whether items are similar enough to join
+// i.e. no state differences between the 2 items.
+bool RasterizerCanvasGLES2::try_join_item(Item *ci, RIState &ris, bool &r_batch_break) {
+	//return false;
+
+	// if there are any state changes we change join to false
+	// we also set r_batch_break to true if we don't want this item joined
+	r_batch_break = false;
+	bool join = true;
+
+	if (ris.current_clip != ci->final_clip_owner) {
+		ris.current_clip = ci->final_clip_owner;
+		join = false;
+	}
 
-		if (current_clip != ci->final_clip_owner) {
+	// TODO: copy back buffer
 
-			current_clip = ci->final_clip_owner;
+	if (ci->copy_back_buffer) {
+		join = false;
+	}
 
-			if (current_clip) {
-				glEnable(GL_SCISSOR_TEST);
-				int y = storage->frame.current_rt->height - (current_clip->final_clip_rect.position.y + current_clip->final_clip_rect.size.y);
-				if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_VFLIP])
-					y = current_clip->final_clip_rect.position.y;
-				glScissor(current_clip->final_clip_rect.position.x, y, current_clip->final_clip_rect.size.width, current_clip->final_clip_rect.size.height);
-			} else {
-				glDisable(GL_SCISSOR_TEST);
+	RasterizerStorageGLES2::Skeleton *skeleton = NULL;
+
+	{
+		//skeleton handling
+		if (ci->skeleton.is_valid() && storage->skeleton_owner.owns(ci->skeleton)) {
+			skeleton = storage->skeleton_owner.get(ci->skeleton);
+			if (!skeleton->use_2d) {
+				skeleton = NULL;
 			}
 		}
 
-		// TODO: copy back buffer
+		bool use_skeleton = skeleton != NULL;
+		if (ris.prev_use_skeleton != use_skeleton) {
+			ris.rebind_shader = true;
+			ris.prev_use_skeleton = use_skeleton;
+			join = false;
+		}
 
-		if (ci->copy_back_buffer) {
-			if (ci->copy_back_buffer->full) {
-				_copy_texscreen(Rect2());
-			} else {
-				_copy_texscreen(ci->copy_back_buffer->rect);
-			}
+		if (skeleton) {
+			join = false;
+			state.using_skeleton = true;
+		} else {
+			state.using_skeleton = false;
 		}
+	}
 
-		RasterizerStorageGLES2::Skeleton *skeleton = NULL;
+	Item *material_owner = ci->material_owner ? ci->material_owner : ci;
 
-		{
-			//skeleton handling
-			if (ci->skeleton.is_valid() && storage->skeleton_owner.owns(ci->skeleton)) {
-				skeleton = storage->skeleton_owner.get(ci->skeleton);
-				if (!skeleton->use_2d) {
-					skeleton = NULL;
-				} else {
-					state.skeleton_transform = p_base_transform * skeleton->base_transform_2d;
-					state.skeleton_transform_inverse = state.skeleton_transform.affine_inverse();
-					state.skeleton_texture_size = Vector2(skeleton->size * 2, 0);
-				}
-			}
+	RID material = material_owner->material;
+	RasterizerStorageGLES2::Material *material_ptr = storage->material_owner.getornull(material);
+
+	if (material != ris.canvas_last_material || ris.rebind_shader) {
 
-			bool use_skeleton = skeleton != NULL;
-			if (prev_use_skeleton != use_skeleton) {
-				rebind_shader = true;
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SKELETON, use_skeleton);
-				prev_use_skeleton = use_skeleton;
+		join = false;
+		RasterizerStorageGLES2::Shader *shader_ptr = NULL;
+
+		if (material_ptr) {
+			shader_ptr = material_ptr->shader;
+
+			if (shader_ptr && shader_ptr->mode != VS::SHADER_CANVAS_ITEM) {
+				shader_ptr = NULL; // not a canvas item shader, don't use.
 			}
+		}
 
-			if (skeleton) {
-				glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 3);
-				glBindTexture(GL_TEXTURE_2D, skeleton->tex_id);
-				state.using_skeleton = true;
-			} else {
-				state.using_skeleton = false;
+		if (shader_ptr) {
+			if (shader_ptr->canvas_item.uses_screen_texture) {
+				if (!state.canvas_texscreen_used) {
+					join = false;
+				}
 			}
 		}
 
-		Item *material_owner = ci->material_owner ? ci->material_owner : ci;
+		ris.shader_cache = shader_ptr;
 
-		RID material = material_owner->material;
-		RasterizerStorageGLES2::Material *material_ptr = storage->material_owner.getornull(material);
+		ris.canvas_last_material = material;
 
-		if (material != canvas_last_material || rebind_shader) {
+		ris.rebind_shader = false;
+	}
 
-			RasterizerStorageGLES2::Shader *shader_ptr = NULL;
+	int blend_mode = ris.shader_cache ? ris.shader_cache->canvas_item.blend_mode : RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX;
+	bool unshaded = ris.shader_cache && (ris.shader_cache->canvas_item.light_mode == RasterizerStorageGLES2::Shader::CanvasItem::LIGHT_MODE_UNSHADED || (blend_mode != RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX && blend_mode != RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_PMALPHA));
+	bool reclip = false;
 
-			if (material_ptr) {
-				shader_ptr = material_ptr->shader;
+	if (ris.last_blend_mode != blend_mode) {
+		join = false;
+		ris.last_blend_mode = blend_mode;
+	}
 
-				if (shader_ptr && shader_ptr->mode != VS::SHADER_CANVAS_ITEM) {
-					shader_ptr = NULL; // not a canvas item shader, don't use.
-				}
-			}
+	//	state.uniforms.final_modulate = unshaded ? ci->final_modulate : Color(ci->final_modulate.r * ris.IG_modulate.r, ci->final_modulate.g * ris.IG_modulate.g, ci->final_modulate.b * ris.IG_modulate.b, ci->final_modulate.a * ris.IG_modulate.a);
 
-			if (shader_ptr) {
-				if (shader_ptr->canvas_item.uses_screen_texture) {
-					if (!state.canvas_texscreen_used) {
-						//copy if not copied before
-						_copy_texscreen(Rect2());
+	//	state.uniforms.modelview_matrix = ci->final_transform;
+	//	state.uniforms.extra_matrix = Transform2D();
 
-						// blend mode will have been enabled so make sure we disable it again later on
-						//last_blend_mode = last_blend_mode != RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_DISABLED ? last_blend_mode : -1;
-					}
+	//	_set_uniforms();
 
-					if (storage->frame.current_rt->copy_screen_effect.color) {
-						glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 4);
-						glBindTexture(GL_TEXTURE_2D, storage->frame.current_rt->copy_screen_effect.color);
-					}
-				}
+	//	if (unshaded || (state.uniforms.final_modulate.a > 0.001 && (!ris.shader_cache || ris.shader_cache->canvas_item.light_mode != RasterizerStorageGLES2::Shader::CanvasItem::LIGHT_MODE_LIGHT_ONLY) && !ci->light_masked))
+	//		_canvas_item_render_commands(ci, NULL, reclip, material_ptr);
 
-				if (shader_ptr != shader_cache) {
+	// this will screw up all joins, remove?
+	//	ris.rebind_shader = true; // hacked in for now.
 
-					if (shader_ptr->canvas_item.uses_time) {
-						VisualServerRaster::redraw_request();
-					}
+	if ((blend_mode == RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX || blend_mode == RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_PMALPHA) && ris.IG_light && !unshaded) {
 
-					state.canvas_shader.set_custom_shader(shader_ptr->custom_code_id);
-					state.canvas_shader.bind();
-				}
+		// we cannot join lit items easily.
+		// it is possible, but not if they overlap, because
+		// a + light_blend + b + light_blend IS NOT THE SAME AS
+		// a + b + light_blend
+		join = false;
 
-				int tc = material_ptr->textures.size();
-				Pair<StringName, RID> *textures = material_ptr->textures.ptrw();
+		// just an alias
+		//		Light *light = ris.IG_light;
 
-				ShaderLanguage::ShaderNode::Uniform::Hint *texture_hints = shader_ptr->texture_hints.ptrw();
+		//		if (ci->final_modulate != ris.final_modulate)
+		//		{
 
-				for (int i = 0; i < tc; i++) {
+		//			// keep track of the final modulate color state used by lighting ..
+		//			// if this changes between items, cannot join
+		//			ris.final_modulate = ci->final_modulate;
+		//		}
 
-					glActiveTexture(GL_TEXTURE0 + i);
+		//		bool light_used = false;
+		//		VS::CanvasLightMode mode = VS::CANVAS_LIGHT_MODE_ADD;
+		//		state.uniforms.final_modulate = ci->final_modulate; // remove the canvas modulate
 
-					RasterizerStorageGLES2::Texture *t = storage->texture_owner.getornull(textures[i].second);
+		//		while (light) {
 
-					if (!t) {
+		//			if (ci->light_mask & light->item_mask && ris.IG_z >= light->z_min && ris.IG_z <= light->z_max && ci->global_rect_cache.intersects_transformed(light->xform_cache, light->rect_cache)) {
 
-						switch (texture_hints[i]) {
-							case ShaderLanguage::ShaderNode::Uniform::HINT_BLACK_ALBEDO:
-							case ShaderLanguage::ShaderNode::Uniform::HINT_BLACK: {
-								glBindTexture(GL_TEXTURE_2D, storage->resources.black_tex);
-							} break;
-							case ShaderLanguage::ShaderNode::Uniform::HINT_ANISO: {
-								glBindTexture(GL_TEXTURE_2D, storage->resources.aniso_tex);
-							} break;
-							case ShaderLanguage::ShaderNode::Uniform::HINT_NORMAL: {
-								glBindTexture(GL_TEXTURE_2D, storage->resources.normal_tex);
-							} break;
-							default: {
-								glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
-							} break;
-						}
+		//				//intersects this light
 
-						continue;
-					}
+		//				if (!light_used || mode != light->mode) {
 
-					if (t->redraw_if_visible) {
-						VisualServerRaster::redraw_request();
-					}
+		//					mode = light->mode;
 
-					t = t->get_ptr();
+		//					switch (mode) {
 
-#ifdef TOOLS_ENABLED
-					if (t->detect_normal && texture_hints[i] == ShaderLanguage::ShaderNode::Uniform::HINT_NORMAL) {
-						t->detect_normal(t->detect_normal_ud);
-					}
-#endif
-					if (t->render_target)
-						t->render_target->used_in_frame = true;
+		//						case VS::CANVAS_LIGHT_MODE_ADD: {
+		//							glBlendEquation(GL_FUNC_ADD);
+		//							glBlendFunc(GL_SRC_ALPHA, GL_ONE);
 
-					glBindTexture(t->target, t->tex_id);
-				}
+		//						} break;
+		//						case VS::CANVAS_LIGHT_MODE_SUB: {
+		//							glBlendEquation(GL_FUNC_REVERSE_SUBTRACT);
+		//							glBlendFunc(GL_SRC_ALPHA, GL_ONE);
+		//						} break;
+		//						case VS::CANVAS_LIGHT_MODE_MIX:
+		//						case VS::CANVAS_LIGHT_MODE_MASK: {
+		//							glBlendEquation(GL_FUNC_ADD);
+		//							glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
-			} else {
-				state.canvas_shader.set_custom_shader(0);
-				state.canvas_shader.bind();
-			}
-			state.canvas_shader.use_material((void *)material_ptr);
+		//						} break;
+		//					}
+		//				}
 
-			shader_cache = shader_ptr;
+		//				if (!light_used) {
 
-			canvas_last_material = material;
+		//					state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_LIGHTING, true);
+		//					light_used = true;
+		//				}
 
-			rebind_shader = false;
-		}
+		//				bool has_shadow = light->shadow_buffer.is_valid() && ci->light_mask & light->item_shadow_mask;
 
-		int blend_mode = shader_cache ? shader_cache->canvas_item.blend_mode : RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX;
-		bool unshaded = shader_cache && (shader_cache->canvas_item.light_mode == RasterizerStorageGLES2::Shader::CanvasItem::LIGHT_MODE_UNSHADED || (blend_mode != RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX && blend_mode != RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_PMALPHA));
-		bool reclip = false;
+		//				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SHADOWS, has_shadow);
+		//				if (has_shadow) {
+		//					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_USE_GRADIENT, light->shadow_gradient_length > 0);
+		//					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_NEAREST, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_NONE);
+		//					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF3, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF3);
+		//					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF5, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF5);
+		//					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF7, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF7);
+		//					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF9, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF9);
+		//					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF13, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF13);
+		//				}
 
-		if (last_blend_mode != blend_mode) {
+		//				state.canvas_shader.bind();
+		//				state.using_light = light;
+		//				state.using_shadow = has_shadow;
 
-			switch (blend_mode) {
+		//				//always re-set uniforms, since light parameters changed
+		//				_set_uniforms();
+		//				state.canvas_shader.use_material((void *)material_ptr);
 
-				case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX: {
-					glBlendEquation(GL_FUNC_ADD);
-					if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
-						glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
-					} else {
-						glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);
-					}
+		//				glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 4);
+		//				RasterizerStorageGLES2::Texture *t = storage->texture_owner.getornull(light->texture);
+		//				if (!t) {
+		//					glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
+		//				} else {
+		//					t = t->get_ptr();
 
-				} break;
-				case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_ADD: {
+		//					glBindTexture(t->target, t->tex_id);
+		//				}
 
-					glBlendEquation(GL_FUNC_ADD);
-					if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
-						glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_SRC_ALPHA, GL_ONE);
-					} else {
-						glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_ZERO, GL_ONE);
-					}
+		//				glActiveTexture(GL_TEXTURE0);
+		//				_canvas_item_render_commands(ci, NULL, reclip, material_ptr); //redraw using light
 
-				} break;
-				case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_SUB: {
+		//				state.using_light = NULL;
+		//			}
 
-					glBlendEquation(GL_FUNC_REVERSE_SUBTRACT);
-					if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
-						glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_SRC_ALPHA, GL_ONE);
-					} else {
-						glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_ZERO, GL_ONE);
-					}
-				} break;
-				case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MUL: {
-					glBlendEquation(GL_FUNC_ADD);
-					if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
-						glBlendFuncSeparate(GL_DST_COLOR, GL_ZERO, GL_DST_ALPHA, GL_ZERO);
-					} else {
-						glBlendFuncSeparate(GL_DST_COLOR, GL_ZERO, GL_ZERO, GL_ONE);
-					}
+		//			light = light->next_ptr;
+		//		}
+
+		//		if (light_used) {
+
+		//			state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_LIGHTING, false);
+		//			state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SHADOWS, false);
+		//			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_NEAREST, false);
+		//			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF3, false);
+		//			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF5, false);
+		//			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF7, false);
+		//			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF9, false);
+		//			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF13, false);
+
+		//			state.canvas_shader.bind();
+
+		//			ris.last_blend_mode = -1;
+		//		}
+	}
+
+	if (reclip) {
+		join = false;
+	}
+
+	// non rects will break the batching anyway, we don't want to record item changes, detect this
+	if (_detect_batch_break(ci)) {
+		join = false;
+		r_batch_break = true;
+	}
+
+	return join;
+}
+
+bool RasterizerCanvasGLES2::_detect_batch_break(Item *ci) {
+	int command_count = ci->commands.size();
+
+	// It is hard to know what this number should be, empirically,
+	// and this has not been fully investigated. It works to join single sprite items when set to 1 or above.
+	// Note that there is a cost to increasing this because it has to look in advance through
+	// the commands.
+	// On the other hand joining items where possible will usually be better up to a certain
+	// number where the cost of software transform is higher than separate drawcalls with hardware
+	// transform.
+
+	// if there are more than this number of commands in the item, we
+	// don't allow joining (separate state changes, and hardware transform)
+	// This is set to quite a conservative (low) number until investigated properly.
+	const int MAX_JOIN_ITEM_COMMANDS = 16;
+
+	if (command_count > MAX_JOIN_ITEM_COMMANDS) {
+		return true;
+	} else {
+		Item::Command *const *commands = ci->commands.ptr();
+
+		// do as many commands as possible until the vertex buffer will be full up
+		for (int command_num = 0; command_num < command_count; command_num++) {
+
+			Item::Command *command = commands[command_num];
+			CRASH_COND(!command);
+
+			switch (command->type) {
+
+				default: {
+					return true;
 				} break;
-				case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_PMALPHA: {
-					glBlendEquation(GL_FUNC_ADD);
-					if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
-						glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
-					} else {
-						glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);
-					}
+				case Item::Command::TYPE_RECT: {
 				} break;
-			}
+			} // switch
+
+		} // for through commands
+
+	} // else
+
+	return false;
+}
+
+void RasterizerCanvasGLES2::_canvas_render_item(Item *ci, RIState &ris) {
+	if (ris.current_clip != ci->final_clip_owner) {
+
+		ris.current_clip = ci->final_clip_owner;
+
+		if (ris.current_clip) {
+			glEnable(GL_SCISSOR_TEST);
+			int y = storage->frame.current_rt->height - (ris.current_clip->final_clip_rect.position.y + ris.current_clip->final_clip_rect.size.y);
+			if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_VFLIP])
+				y = ris.current_clip->final_clip_rect.position.y;
+			glScissor(ris.current_clip->final_clip_rect.position.x, y, ris.current_clip->final_clip_rect.size.width, ris.current_clip->final_clip_rect.size.height);
+		} else {
+			glDisable(GL_SCISSOR_TEST);
 		}
+	}
 
-		state.uniforms.final_modulate = unshaded ? ci->final_modulate : Color(ci->final_modulate.r * p_modulate.r, ci->final_modulate.g * p_modulate.g, ci->final_modulate.b * p_modulate.b, ci->final_modulate.a * p_modulate.a);
+	// TODO: copy back buffer
 
-		state.uniforms.modelview_matrix = ci->final_transform;
-		state.uniforms.extra_matrix = Transform2D();
+	if (ci->copy_back_buffer) {
+		if (ci->copy_back_buffer->full) {
+			_copy_texscreen(Rect2());
+		} else {
+			_copy_texscreen(ci->copy_back_buffer->rect);
+		}
+	}
 
-		_set_uniforms();
+	RasterizerStorageGLES2::Skeleton *skeleton = NULL;
 
-		if (unshaded || (state.uniforms.final_modulate.a > 0.001 && (!shader_cache || shader_cache->canvas_item.light_mode != RasterizerStorageGLES2::Shader::CanvasItem::LIGHT_MODE_LIGHT_ONLY) && !ci->light_masked))
-			_canvas_item_render_commands(p_item_list, NULL, reclip, material_ptr);
+	{
+		//skeleton handling
+		if (ci->skeleton.is_valid() && storage->skeleton_owner.owns(ci->skeleton)) {
+			skeleton = storage->skeleton_owner.get(ci->skeleton);
+			if (!skeleton->use_2d) {
+				skeleton = NULL;
+			} else {
+				state.skeleton_transform = ris.IG_base_transform * skeleton->base_transform_2d;
+				state.skeleton_transform_inverse = state.skeleton_transform.affine_inverse();
+				state.skeleton_texture_size = Vector2(skeleton->size * 2, 0);
+			}
+		}
 
-		rebind_shader = true; // hacked in for now.
+		bool use_skeleton = skeleton != NULL;
+		if (ris.prev_use_skeleton != use_skeleton) {
+			ris.rebind_shader = true;
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SKELETON, use_skeleton);
+			ris.prev_use_skeleton = use_skeleton;
+		}
 
-		if ((blend_mode == RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX || blend_mode == RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_PMALPHA) && p_light && !unshaded) {
+		if (skeleton) {
+			glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 3);
+			glBindTexture(GL_TEXTURE_2D, skeleton->tex_id);
+			state.using_skeleton = true;
+		} else {
+			state.using_skeleton = false;
+		}
+	}
 
-			Light *light = p_light;
-			bool light_used = false;
-			VS::CanvasLightMode mode = VS::CANVAS_LIGHT_MODE_ADD;
-			state.uniforms.final_modulate = ci->final_modulate; // remove the canvas modulate
+	Item *material_owner = ci->material_owner ? ci->material_owner : ci;
 
-			while (light) {
+	RID material = material_owner->material;
+	RasterizerStorageGLES2::Material *material_ptr = storage->material_owner.getornull(material);
 
-				if (ci->light_mask & light->item_mask && p_z >= light->z_min && p_z <= light->z_max && ci->global_rect_cache.intersects_transformed(light->xform_cache, light->rect_cache)) {
+	if (material != ris.canvas_last_material || ris.rebind_shader) {
 
-					//intersects this light
+		RasterizerStorageGLES2::Shader *shader_ptr = NULL;
 
-					if (!light_used || mode != light->mode) {
+		if (material_ptr) {
+			shader_ptr = material_ptr->shader;
 
-						mode = light->mode;
+			if (shader_ptr && shader_ptr->mode != VS::SHADER_CANVAS_ITEM) {
+				shader_ptr = NULL; // not a canvas item shader, don't use.
+			}
+		}
 
-						switch (mode) {
+		if (shader_ptr) {
+			if (shader_ptr->canvas_item.uses_screen_texture) {
+				if (!state.canvas_texscreen_used) {
+					//copy if not copied before
+					_copy_texscreen(Rect2());
 
-							case VS::CANVAS_LIGHT_MODE_ADD: {
-								glBlendEquation(GL_FUNC_ADD);
-								glBlendFunc(GL_SRC_ALPHA, GL_ONE);
+					// blend mode will have been enabled so make sure we disable it again later on
+					//last_blend_mode = last_blend_mode != RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_DISABLED ? last_blend_mode : -1;
+				}
 
-							} break;
-							case VS::CANVAS_LIGHT_MODE_SUB: {
-								glBlendEquation(GL_FUNC_REVERSE_SUBTRACT);
-								glBlendFunc(GL_SRC_ALPHA, GL_ONE);
-							} break;
-							case VS::CANVAS_LIGHT_MODE_MIX:
-							case VS::CANVAS_LIGHT_MODE_MASK: {
-								glBlendEquation(GL_FUNC_ADD);
-								glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+				if (storage->frame.current_rt->copy_screen_effect.color) {
+					glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 4);
+					glBindTexture(GL_TEXTURE_2D, storage->frame.current_rt->copy_screen_effect.color);
+				}
+			}
 
-							} break;
-						}
-					}
+			if (shader_ptr != ris.shader_cache) {
 
-					if (!light_used) {
+				if (shader_ptr->canvas_item.uses_time) {
+					VisualServerRaster::redraw_request();
+				}
 
-						state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_LIGHTING, true);
-						light_used = true;
-					}
+				state.canvas_shader.set_custom_shader(shader_ptr->custom_code_id);
+				state.canvas_shader.bind();
+			}
 
-					bool has_shadow = light->shadow_buffer.is_valid() && ci->light_mask & light->item_shadow_mask;
-
-					state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SHADOWS, has_shadow);
-					if (has_shadow) {
-						state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_USE_GRADIENT, light->shadow_gradient_length > 0);
-						state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_NEAREST, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_NONE);
-						state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF3, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF3);
-						state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF5, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF5);
-						state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF7, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF7);
-						state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF9, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF9);
-						state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF13, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF13);
-					}
+			int tc = material_ptr->textures.size();
+			Pair<StringName, RID> *textures = material_ptr->textures.ptrw();
 
-					state.canvas_shader.bind();
-					state.using_light = light;
-					state.using_shadow = has_shadow;
+			ShaderLanguage::ShaderNode::Uniform::Hint *texture_hints = shader_ptr->texture_hints.ptrw();
 
-					//always re-set uniforms, since light parameters changed
-					_set_uniforms();
-					state.canvas_shader.use_material((void *)material_ptr);
+			for (int i = 0; i < tc; i++) {
 
-					glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 4);
-					RasterizerStorageGLES2::Texture *t = storage->texture_owner.getornull(light->texture);
-					if (!t) {
-						glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
-					} else {
-						t = t->get_ptr();
+				glActiveTexture(GL_TEXTURE0 + i);
+
+				RasterizerStorageGLES2::Texture *t = storage->texture_owner.getornull(textures[i].second);
 
-						glBindTexture(t->target, t->tex_id);
+				if (!t) {
+
+					switch (texture_hints[i]) {
+						case ShaderLanguage::ShaderNode::Uniform::HINT_BLACK_ALBEDO:
+						case ShaderLanguage::ShaderNode::Uniform::HINT_BLACK: {
+							glBindTexture(GL_TEXTURE_2D, storage->resources.black_tex);
+						} break;
+						case ShaderLanguage::ShaderNode::Uniform::HINT_ANISO: {
+							glBindTexture(GL_TEXTURE_2D, storage->resources.aniso_tex);
+						} break;
+						case ShaderLanguage::ShaderNode::Uniform::HINT_NORMAL: {
+							glBindTexture(GL_TEXTURE_2D, storage->resources.normal_tex);
+						} break;
+						default: {
+							glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
+						} break;
 					}
 
-					glActiveTexture(GL_TEXTURE0);
-					_canvas_item_render_commands(p_item_list, NULL, reclip, material_ptr); //redraw using light
+					continue;
+				}
 
-					state.using_light = NULL;
+				if (t->redraw_if_visible) {
+					VisualServerRaster::redraw_request();
+				}
+
+				t = t->get_ptr();
+
+#ifdef TOOLS_ENABLED
+				if (t->detect_normal && texture_hints[i] == ShaderLanguage::ShaderNode::Uniform::HINT_NORMAL) {
+					t->detect_normal(t->detect_normal_ud);
 				}
+#endif
+				if (t->render_target)
+					t->render_target->used_in_frame = true;
 
-				light = light->next_ptr;
+				glBindTexture(t->target, t->tex_id);
 			}
 
-			if (light_used) {
+		} else {
+			state.canvas_shader.set_custom_shader(0);
+			state.canvas_shader.bind();
+		}
+		state.canvas_shader.use_material((void *)material_ptr);
 
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_LIGHTING, false);
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SHADOWS, false);
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_NEAREST, false);
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF3, false);
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF5, false);
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF7, false);
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF9, false);
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF13, false);
+		ris.shader_cache = shader_ptr;
 
-				state.canvas_shader.bind();
+		ris.canvas_last_material = material;
 
-				last_blend_mode = -1;
+		ris.rebind_shader = false;
+	}
 
-				/*
-				//this is set again, so it should not be needed anyway?
-				state.canvas_item_modulate = unshaded ? ci->final_modulate : Color(
-							ci->final_modulate.r * p_modulate.r,
-							ci->final_modulate.g * p_modulate.g,
-							ci->final_modulate.b * p_modulate.b,
-							ci->final_modulate.a * p_modulate.a );
+	int blend_mode = ris.shader_cache ? ris.shader_cache->canvas_item.blend_mode : RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX;
+	bool unshaded = ris.shader_cache && (ris.shader_cache->canvas_item.light_mode == RasterizerStorageGLES2::Shader::CanvasItem::LIGHT_MODE_UNSHADED || (blend_mode != RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX && blend_mode != RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_PMALPHA));
+	bool reclip = false;
 
+	if (ris.last_blend_mode != blend_mode) {
 
-				state.canvas_shader.set_uniform(CanvasShaderGLES2::MODELVIEW_MATRIX,state.final_transform);
-				state.canvas_shader.set_uniform(CanvasShaderGLES2::EXTRA_MATRIX,Transform2D());
-				state.canvas_shader.set_uniform(CanvasShaderGLES2::FINAL_MODULATE,state.canvas_item_modulate);
+		switch (blend_mode) {
 
+			case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX: {
 				glBlendEquation(GL_FUNC_ADD);
-
-				if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
+				if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
 					glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
 				} else {
-					glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+					glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);
 				}
 
-				//@TODO RESET canvas_blend_mode
-				*/
-			}
-		}
+			} break;
+			case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_ADD: {
 
-		if (reclip) {
-			glEnable(GL_SCISSOR_TEST);
-			int y = storage->frame.current_rt->height - (current_clip->final_clip_rect.position.y + current_clip->final_clip_rect.size.y);
-			if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_VFLIP])
-				y = current_clip->final_clip_rect.position.y;
-			glScissor(current_clip->final_clip_rect.position.x, y, current_clip->final_clip_rect.size.width, current_clip->final_clip_rect.size.height);
-		}
+				glBlendEquation(GL_FUNC_ADD);
+				if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
+					glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_SRC_ALPHA, GL_ONE);
+				} else {
+					glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_ZERO, GL_ONE);
+				}
 
-		p_item_list = p_item_list->next;
-	}
+			} break;
+			case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_SUB: {
 
-	if (current_clip) {
-		glDisable(GL_SCISSOR_TEST);
+				glBlendEquation(GL_FUNC_REVERSE_SUBTRACT);
+				if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
+					glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_SRC_ALPHA, GL_ONE);
+				} else {
+					glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_ZERO, GL_ONE);
+				}
+			} break;
+			case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MUL: {
+				glBlendEquation(GL_FUNC_ADD);
+				if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
+					glBlendFuncSeparate(GL_DST_COLOR, GL_ZERO, GL_DST_ALPHA, GL_ZERO);
+				} else {
+					glBlendFuncSeparate(GL_DST_COLOR, GL_ZERO, GL_ZERO, GL_ONE);
+				}
+			} break;
+			case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_PMALPHA: {
+				glBlendEquation(GL_FUNC_ADD);
+				if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
+					glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+				} else {
+					glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);
+				}
+			} break;
+		}
 	}
 
-	state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SKELETON, false);
-}
+	state.uniforms.final_modulate = unshaded ? ci->final_modulate : Color(ci->final_modulate.r * ris.IG_modulate.r, ci->final_modulate.g * ris.IG_modulate.g, ci->final_modulate.b * ris.IG_modulate.b, ci->final_modulate.a * ris.IG_modulate.a);
 
-void RasterizerCanvasGLES2::canvas_debug_viewport_shadows(Light *p_lights_with_shadow) {
-}
+	state.uniforms.modelview_matrix = ci->final_transform;
+	state.uniforms.extra_matrix = Transform2D();
 
-void RasterizerCanvasGLES2::canvas_light_shadow_buffer_update(RID p_buffer, const Transform2D &p_light_xform, int p_light_mask, float p_near, float p_far, LightOccluderInstance *p_occluders, CameraMatrix *p_xform_cache) {
+	_set_uniforms();
 
-	RasterizerStorageGLES2::CanvasLightShadow *cls = storage->canvas_light_shadow_owner.get(p_buffer);
-	ERR_FAIL_COND(!cls);
+	if (unshaded || (state.uniforms.final_modulate.a > 0.001 && (!ris.shader_cache || ris.shader_cache->canvas_item.light_mode != RasterizerStorageGLES2::Shader::CanvasItem::LIGHT_MODE_LIGHT_ONLY) && !ci->light_masked))
+		_canvas_item_render_commands(ci, NULL, reclip, material_ptr);
 
-	glDisable(GL_BLEND);
-	glDisable(GL_SCISSOR_TEST);
-	glDisable(GL_DITHER);
-	glDisable(GL_CULL_FACE);
-	glDepthFunc(GL_LEQUAL);
-	glEnable(GL_DEPTH_TEST);
-	glDepthMask(true);
+	ris.rebind_shader = true; // hacked in for now.
 
-	glBindFramebuffer(GL_FRAMEBUFFER, cls->fbo);
+	if ((blend_mode == RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX || blend_mode == RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_PMALPHA) && ris.IG_light && !unshaded) {
 
-	state.canvas_shadow_shader.set_conditional(CanvasShadowShaderGLES2::USE_RGBA_SHADOWS, storage->config.use_rgba_2d_shadows);
-	state.canvas_shadow_shader.bind();
+		Light *light = ris.IG_light;
+		bool light_used = false;
+		VS::CanvasLightMode mode = VS::CANVAS_LIGHT_MODE_ADD;
+		state.uniforms.final_modulate = ci->final_modulate; // remove the canvas modulate
 
-	glViewport(0, 0, cls->size, cls->height);
-	glClearDepth(1.0f);
-	glClearColor(1, 1, 1, 1);
-	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+		while (light) {
 
-	VS::CanvasOccluderPolygonCullMode cull = VS::CANVAS_OCCLUDER_POLYGON_CULL_DISABLED;
+			if (ci->light_mask & light->item_mask && ris.IG_z >= light->z_min && ris.IG_z <= light->z_max && ci->global_rect_cache.intersects_transformed(light->xform_cache, light->rect_cache)) {
 
-	for (int i = 0; i < 4; i++) {
+				//intersects this light
 
-		//make sure it remains orthogonal, makes easy to read angle later
+				if (!light_used || mode != light->mode) {
 
-		Transform light;
-		light.origin[0] = p_light_xform[2][0];
-		light.origin[1] = p_light_xform[2][1];
-		light.basis[0][0] = p_light_xform[0][0];
-		light.basis[0][1] = p_light_xform[1][0];
-		light.basis[1][0] = p_light_xform[0][1];
-		light.basis[1][1] = p_light_xform[1][1];
+					mode = light->mode;
 
-		//light.basis.scale(Vector3(to_light.elements[0].length(),to_light.elements[1].length(),1));
+					switch (mode) {
 
-		//p_near=1;
-		CameraMatrix projection;
-		{
-			real_t fov = 90;
-			real_t nearp = p_near;
-			real_t farp = p_far;
-			real_t aspect = 1.0;
+						case VS::CANVAS_LIGHT_MODE_ADD: {
+							glBlendEquation(GL_FUNC_ADD);
+							glBlendFunc(GL_SRC_ALPHA, GL_ONE);
 
-			real_t ymax = nearp * Math::tan(Math::deg2rad(fov * 0.5));
-			real_t ymin = -ymax;
-			real_t xmin = ymin * aspect;
-			real_t xmax = ymax * aspect;
+						} break;
+						case VS::CANVAS_LIGHT_MODE_SUB: {
+							glBlendEquation(GL_FUNC_REVERSE_SUBTRACT);
+							glBlendFunc(GL_SRC_ALPHA, GL_ONE);
+						} break;
+						case VS::CANVAS_LIGHT_MODE_MIX:
+						case VS::CANVAS_LIGHT_MODE_MASK: {
+							glBlendEquation(GL_FUNC_ADD);
+							glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
-			projection.set_frustum(xmin, xmax, ymin, ymax, nearp, farp);
-		}
+						} break;
+					}
+				}
+
+				if (!light_used) {
 
-		Vector3 cam_target = Basis(Vector3(0, 0, Math_PI * 2 * (i / 4.0))).xform(Vector3(0, 1, 0));
-		projection = projection * CameraMatrix(Transform().looking_at(cam_target, Vector3(0, 0, -1)).affine_inverse());
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_LIGHTING, true);
+					light_used = true;
+				}
 
-		state.canvas_shadow_shader.set_uniform(CanvasShadowShaderGLES2::PROJECTION_MATRIX, projection);
-		state.canvas_shadow_shader.set_uniform(CanvasShadowShaderGLES2::LIGHT_MATRIX, light);
-		state.canvas_shadow_shader.set_uniform(CanvasShadowShaderGLES2::DISTANCE_NORM, 1.0 / p_far);
+				bool has_shadow = light->shadow_buffer.is_valid() && ci->light_mask & light->item_shadow_mask;
+
+				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SHADOWS, has_shadow);
+				if (has_shadow) {
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_USE_GRADIENT, light->shadow_gradient_length > 0);
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_NEAREST, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_NONE);
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF3, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF3);
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF5, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF5);
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF7, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF7);
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF9, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF9);
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF13, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF13);
+				}
 
-		if (i == 0)
-			*p_xform_cache = projection;
+				state.canvas_shader.bind();
+				state.using_light = light;
+				state.using_shadow = has_shadow;
 
-		glViewport(0, (cls->height / 4) * i, cls->size, cls->height / 4);
+				//always re-set uniforms, since light parameters changed
+				_set_uniforms();
+				state.canvas_shader.use_material((void *)material_ptr);
 
-		LightOccluderInstance *instance = p_occluders;
+				glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 4);
+				RasterizerStorageGLES2::Texture *t = storage->texture_owner.getornull(light->texture);
+				if (!t) {
+					glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
+				} else {
+					t = t->get_ptr();
 
-		while (instance) {
+					glBindTexture(t->target, t->tex_id);
+				}
 
-			RasterizerStorageGLES2::CanvasOccluder *cc = storage->canvas_occluder_owner.getornull(instance->polygon_buffer);
-			if (!cc || cc->len == 0 || !(p_light_mask & instance->light_mask)) {
+				glActiveTexture(GL_TEXTURE0);
+				_canvas_item_render_commands(ci, NULL, reclip, material_ptr); //redraw using light
 
-				instance = instance->next;
-				continue;
+				state.using_light = NULL;
 			}
 
-			state.canvas_shadow_shader.set_uniform(CanvasShadowShaderGLES2::WORLD_MATRIX, instance->xform_cache);
+			light = light->next_ptr;
+		}
 
-			VS::CanvasOccluderPolygonCullMode transformed_cull_cache = instance->cull_cache;
+		if (light_used) {
 
-			if (transformed_cull_cache != VS::CANVAS_OCCLUDER_POLYGON_CULL_DISABLED &&
-					(p_light_xform.basis_determinant() * instance->xform_cache.basis_determinant()) < 0) {
-				transformed_cull_cache =
-						transformed_cull_cache == VS::CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE ?
-								VS::CANVAS_OCCLUDER_POLYGON_CULL_COUNTER_CLOCKWISE :
-								VS::CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE;
-			}
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_LIGHTING, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SHADOWS, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_NEAREST, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF3, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF5, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF7, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF9, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF13, false);
 
-			if (cull != transformed_cull_cache) {
+			state.canvas_shader.bind();
 
-				cull = transformed_cull_cache;
-				switch (cull) {
-					case VS::CANVAS_OCCLUDER_POLYGON_CULL_DISABLED: {
+			ris.last_blend_mode = -1;
 
-						glDisable(GL_CULL_FACE);
+			/*
+			//this is set again, so it should not be needed anyway?
+			state.canvas_item_modulate = unshaded ? ci->final_modulate : Color(
+						ci->final_modulate.r * p_modulate.r,
+						ci->final_modulate.g * p_modulate.g,
+						ci->final_modulate.b * p_modulate.b,
+						ci->final_modulate.a * p_modulate.a );
 
-					} break;
-					case VS::CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE: {
 
-						glEnable(GL_CULL_FACE);
-						glCullFace(GL_FRONT);
-					} break;
-					case VS::CANVAS_OCCLUDER_POLYGON_CULL_COUNTER_CLOCKWISE: {
+			state.canvas_shader.set_uniform(CanvasShaderGLES2::MODELVIEW_MATRIX,state.final_transform);
+			state.canvas_shader.set_uniform(CanvasShaderGLES2::EXTRA_MATRIX,Transform2D());
+			state.canvas_shader.set_uniform(CanvasShaderGLES2::FINAL_MODULATE,state.canvas_item_modulate);
 
-						glEnable(GL_CULL_FACE);
-						glCullFace(GL_BACK);
+			glBlendEquation(GL_FUNC_ADD);
 
-					} break;
-				}
+			if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
+				glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+			} else {
+				glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 			}
 
-			glBindBuffer(GL_ARRAY_BUFFER, cc->vertex_id);
-			glEnableVertexAttribArray(VS::ARRAY_VERTEX);
-			glVertexAttribPointer(VS::ARRAY_VERTEX, 3, GL_FLOAT, false, 0, 0);
-			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, cc->index_id);
-
-			glDrawElements(GL_TRIANGLES, cc->len * 3, GL_UNSIGNED_SHORT, 0);
-
-			instance = instance->next;
+			//@TODO RESET canvas_blend_mode
+			*/
 		}
 	}
 
-	glBindBuffer(GL_ARRAY_BUFFER, 0);
-	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+	if (reclip) {
+		glEnable(GL_SCISSOR_TEST);
+		int y = storage->frame.current_rt->height - (ris.current_clip->final_clip_rect.position.y + ris.current_clip->final_clip_rect.size.y);
+		if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_VFLIP])
+			y = ris.current_clip->final_clip_rect.position.y;
+		glScissor(ris.current_clip->final_clip_rect.position.x, y, ris.current_clip->final_clip_rect.size.width, ris.current_clip->final_clip_rect.size.height);
+	}
 }
-void RasterizerCanvasGLES2::reset_canvas() {
 
-	glDisable(GL_CULL_FACE);
-	glDisable(GL_DEPTH_TEST);
-	glDisable(GL_SCISSOR_TEST);
-	glDisable(GL_DITHER);
-	glEnable(GL_BLEND);
+void RasterizerCanvasGLES2::render_joined_item(const BItemJoined &bij, RIState &ris) {
 
-	if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
-		glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
-	} else {
-		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-	}
+	// all the joined items will share the same state with the first item
+	Item *ci = bdata.item_refs[bij.first_item_ref].m_pItem;
+
+	if (ris.current_clip != ci->final_clip_owner) {
 
-	// bind the back buffer to a texture so shaders can use it.
-	// It should probably use texture unit -3 (as GLES2 does as well) but currently that's buggy.
-	// keeping this for now as there's nothing else that uses texture unit 2
-	// TODO ^
-	if (storage->frame.current_rt) {
-		// glActiveTexture(GL_TEXTURE0 + 2);
-		// glBindTexture(GL_TEXTURE_2D, storage->frame.current_rt->copy_screen_effect.color);
+		ris.current_clip = ci->final_clip_owner;
+
+		if (ris.current_clip) {
+			glEnable(GL_SCISSOR_TEST);
+			int y = storage->frame.current_rt->height - (ris.current_clip->final_clip_rect.position.y + ris.current_clip->final_clip_rect.size.y);
+			if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_VFLIP])
+				y = ris.current_clip->final_clip_rect.position.y;
+			glScissor(ris.current_clip->final_clip_rect.position.x, y, ris.current_clip->final_clip_rect.size.width, ris.current_clip->final_clip_rect.size.height);
+		} else {
+			glDisable(GL_SCISSOR_TEST);
+		}
 	}
 
-	glBindBuffer(GL_ARRAY_BUFFER, 0);
-	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-}
+	// TODO: copy back buffer
 
-void RasterizerCanvasGLES2::_bind_quad_buffer() {
-	glBindBuffer(GL_ARRAY_BUFFER, data.canvas_quad_vertices);
-	glEnableVertexAttribArray(VS::ARRAY_VERTEX);
-	glVertexAttribPointer(VS::ARRAY_VERTEX, 2, GL_FLOAT, GL_FALSE, 0, NULL);
-}
-void RasterizerCanvasGLES2::draw_generic_textured_rect(const Rect2 &p_rect, const Rect2 &p_src) {
+	if (ci->copy_back_buffer) {
+		if (ci->copy_back_buffer->full) {
+			_copy_texscreen(Rect2());
+		} else {
+			_copy_texscreen(ci->copy_back_buffer->rect);
+		}
+	}
 
-	state.canvas_shader.set_uniform(CanvasShaderGLES2::DST_RECT, Color(p_rect.position.x, p_rect.position.y, p_rect.size.x, p_rect.size.y));
-	state.canvas_shader.set_uniform(CanvasShaderGLES2::SRC_RECT, Color(p_src.position.x, p_src.position.y, p_src.size.x, p_src.size.y));
+	RasterizerStorageGLES2::Skeleton *skeleton = NULL;
 
-	glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
-}
+	{
+		//skeleton handling
+		if (ci->skeleton.is_valid() && storage->skeleton_owner.owns(ci->skeleton)) {
+			skeleton = storage->skeleton_owner.get(ci->skeleton);
+			if (!skeleton->use_2d) {
+				skeleton = NULL;
+			} else {
+				state.skeleton_transform = ris.IG_base_transform * skeleton->base_transform_2d;
+				state.skeleton_transform_inverse = state.skeleton_transform.affine_inverse();
+				state.skeleton_texture_size = Vector2(skeleton->size * 2, 0);
+			}
+		}
 
-void RasterizerCanvasGLES2::draw_lens_distortion_rect(const Rect2 &p_rect, float p_k1, float p_k2, const Vector2 &p_eye_center, float p_oversample) {
-	Vector2 half_size;
-	if (storage->frame.current_rt) {
-		half_size = Vector2(storage->frame.current_rt->width, storage->frame.current_rt->height);
-	} else {
-		half_size = OS::get_singleton()->get_window_size();
+		bool use_skeleton = skeleton != NULL;
+		if (ris.prev_use_skeleton != use_skeleton) {
+			ris.rebind_shader = true;
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SKELETON, use_skeleton);
+			ris.prev_use_skeleton = use_skeleton;
+		}
+
+		if (skeleton) {
+			glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 3);
+			glBindTexture(GL_TEXTURE_2D, skeleton->tex_id);
+			state.using_skeleton = true;
+		} else {
+			state.using_skeleton = false;
+		}
 	}
-	half_size *= 0.5;
-	Vector2 offset((p_rect.position.x - half_size.x) / half_size.x, (p_rect.position.y - half_size.y) / half_size.y);
-	Vector2 scale(p_rect.size.x / half_size.x, p_rect.size.y / half_size.y);
 
-	float aspect_ratio = p_rect.size.x / p_rect.size.y;
+	Item *material_owner = ci->material_owner ? ci->material_owner : ci;
 
-	// setup our lens shader
-	state.lens_shader.bind();
-	state.lens_shader.set_uniform(LensDistortedShaderGLES2::OFFSET, offset);
-	state.lens_shader.set_uniform(LensDistortedShaderGLES2::SCALE, scale);
-	state.lens_shader.set_uniform(LensDistortedShaderGLES2::K1, p_k1);
-	state.lens_shader.set_uniform(LensDistortedShaderGLES2::K2, p_k2);
-	state.lens_shader.set_uniform(LensDistortedShaderGLES2::EYE_CENTER, p_eye_center);
-	state.lens_shader.set_uniform(LensDistortedShaderGLES2::UPSCALE, p_oversample);
-	state.lens_shader.set_uniform(LensDistortedShaderGLES2::ASPECT_RATIO, aspect_ratio);
+	RID material = material_owner->material;
+	RasterizerStorageGLES2::Material *material_ptr = storage->material_owner.getornull(material);
 
-	// bind our quad buffer
-	_bind_quad_buffer();
+	if (material != ris.canvas_last_material || ris.rebind_shader) {
 
-	// and draw
-	glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+		RasterizerStorageGLES2::Shader *shader_ptr = NULL;
 
-	// and cleanup
-	glBindBuffer(GL_ARRAY_BUFFER, 0);
+		if (material_ptr) {
+			shader_ptr = material_ptr->shader;
 
-	for (int i = 0; i < VS::ARRAY_MAX; i++) {
-		glDisableVertexAttribArray(i);
-	}
-}
+			if (shader_ptr && shader_ptr->mode != VS::SHADER_CANVAS_ITEM) {
+				shader_ptr = NULL; // not a canvas item shader, don't use.
+			}
+		}
 
-void RasterizerCanvasGLES2::draw_window_margins(int *black_margin, RID *black_image) {
+		if (shader_ptr) {
+			if (shader_ptr->canvas_item.uses_screen_texture) {
+				if (!state.canvas_texscreen_used) {
+					//copy if not copied before
+					_copy_texscreen(Rect2());
 
-	Vector2 window_size = OS::get_singleton()->get_window_size();
-	int window_h = window_size.height;
-	int window_w = window_size.width;
+					// blend mode will have been enabled so make sure we disable it again later on
+					//last_blend_mode = last_blend_mode != RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_DISABLED ? last_blend_mode : -1;
+				}
 
-	glBindFramebuffer(GL_FRAMEBUFFER, storage->system_fbo);
-	glViewport(0, 0, window_size.width, window_size.height);
-	canvas_begin();
+				if (storage->frame.current_rt->copy_screen_effect.color) {
+					glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 4);
+					glBindTexture(GL_TEXTURE_2D, storage->frame.current_rt->copy_screen_effect.color);
+				}
+			}
 
-	if (black_image[MARGIN_LEFT].is_valid()) {
-		_bind_canvas_texture(black_image[MARGIN_LEFT], RID());
-		Size2 sz(storage->texture_get_width(black_image[MARGIN_LEFT]), storage->texture_get_height(black_image[MARGIN_LEFT]));
-		draw_generic_textured_rect(Rect2(0, 0, black_margin[MARGIN_LEFT], window_h), Rect2(0, 0, sz.x, sz.y));
-	} else if (black_margin[MARGIN_LEFT]) {
-		glActiveTexture(GL_TEXTURE0);
-		glBindTexture(GL_TEXTURE_2D, storage->resources.black_tex);
+			if (shader_ptr != ris.shader_cache) {
 
-		draw_generic_textured_rect(Rect2(0, 0, black_margin[MARGIN_LEFT], window_h), Rect2(0, 0, 1, 1));
-	}
+				if (shader_ptr->canvas_item.uses_time) {
+					VisualServerRaster::redraw_request();
+				}
 
-	if (black_image[MARGIN_RIGHT].is_valid()) {
-		_bind_canvas_texture(black_image[MARGIN_RIGHT], RID());
-		Size2 sz(storage->texture_get_width(black_image[MARGIN_RIGHT]), storage->texture_get_height(black_image[MARGIN_RIGHT]));
-		draw_generic_textured_rect(Rect2(window_w - black_margin[MARGIN_RIGHT], 0, black_margin[MARGIN_RIGHT], window_h), Rect2(0, 0, sz.x, sz.y));
-	} else if (black_margin[MARGIN_RIGHT]) {
-		glActiveTexture(GL_TEXTURE0);
-		glBindTexture(GL_TEXTURE_2D, storage->resources.black_tex);
+				state.canvas_shader.set_custom_shader(shader_ptr->custom_code_id);
+				state.canvas_shader.bind();
+			}
 
-		draw_generic_textured_rect(Rect2(window_w - black_margin[MARGIN_RIGHT], 0, black_margin[MARGIN_RIGHT], window_h), Rect2(0, 0, 1, 1));
-	}
+			int tc = material_ptr->textures.size();
+			Pair<StringName, RID> *textures = material_ptr->textures.ptrw();
 
-	if (black_image[MARGIN_TOP].is_valid()) {
-		_bind_canvas_texture(black_image[MARGIN_TOP], RID());
+			ShaderLanguage::ShaderNode::Uniform::Hint *texture_hints = shader_ptr->texture_hints.ptrw();
 
-		Size2 sz(storage->texture_get_width(black_image[MARGIN_TOP]), storage->texture_get_height(black_image[MARGIN_TOP]));
-		draw_generic_textured_rect(Rect2(0, 0, window_w, black_margin[MARGIN_TOP]), Rect2(0, 0, sz.x, sz.y));
+			for (int i = 0; i < tc; i++) {
 
-	} else if (black_margin[MARGIN_TOP]) {
-		glActiveTexture(GL_TEXTURE0);
-		glBindTexture(GL_TEXTURE_2D, storage->resources.black_tex);
+				glActiveTexture(GL_TEXTURE0 + i);
 
-		draw_generic_textured_rect(Rect2(0, 0, window_w, black_margin[MARGIN_TOP]), Rect2(0, 0, 1, 1));
-	}
+				RasterizerStorageGLES2::Texture *t = storage->texture_owner.getornull(textures[i].second);
 
-	if (black_image[MARGIN_BOTTOM].is_valid()) {
+				if (!t) {
 
-		_bind_canvas_texture(black_image[MARGIN_BOTTOM], RID());
+					switch (texture_hints[i]) {
+						case ShaderLanguage::ShaderNode::Uniform::HINT_BLACK_ALBEDO:
+						case ShaderLanguage::ShaderNode::Uniform::HINT_BLACK: {
+							glBindTexture(GL_TEXTURE_2D, storage->resources.black_tex);
+						} break;
+						case ShaderLanguage::ShaderNode::Uniform::HINT_ANISO: {
+							glBindTexture(GL_TEXTURE_2D, storage->resources.aniso_tex);
+						} break;
+						case ShaderLanguage::ShaderNode::Uniform::HINT_NORMAL: {
+							glBindTexture(GL_TEXTURE_2D, storage->resources.normal_tex);
+						} break;
+						default: {
+							glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
+						} break;
+					}
+
+					continue;
+				}
+
+				if (t->redraw_if_visible) {
+					VisualServerRaster::redraw_request();
+				}
+
+				t = t->get_ptr();
 
-		Size2 sz(storage->texture_get_width(black_image[MARGIN_BOTTOM]), storage->texture_get_height(black_image[MARGIN_BOTTOM]));
-		draw_generic_textured_rect(Rect2(0, window_h - black_margin[MARGIN_BOTTOM], window_w, black_margin[MARGIN_BOTTOM]), Rect2(0, 0, sz.x, sz.y));
+#ifdef TOOLS_ENABLED
+				if (t->detect_normal && texture_hints[i] == ShaderLanguage::ShaderNode::Uniform::HINT_NORMAL) {
+					t->detect_normal(t->detect_normal_ud);
+				}
+#endif
+				if (t->render_target)
+					t->render_target->used_in_frame = true;
+
+				glBindTexture(t->target, t->tex_id);
+			}
+
+		} else {
+			state.canvas_shader.set_custom_shader(0);
+			state.canvas_shader.bind();
+		}
+		state.canvas_shader.use_material((void *)material_ptr);
 
-	} else if (black_margin[MARGIN_BOTTOM]) {
+		ris.shader_cache = shader_ptr;
 
-		glActiveTexture(GL_TEXTURE0);
-		glBindTexture(GL_TEXTURE_2D, storage->resources.black_tex);
+		ris.canvas_last_material = material;
 
-		draw_generic_textured_rect(Rect2(0, window_h - black_margin[MARGIN_BOTTOM], window_w, black_margin[MARGIN_BOTTOM]), Rect2(0, 0, 1, 1));
+		ris.rebind_shader = false;
 	}
 
-	canvas_end();
-}
+	int blend_mode = ris.shader_cache ? ris.shader_cache->canvas_item.blend_mode : RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX;
+	bool unshaded = ris.shader_cache && (ris.shader_cache->canvas_item.light_mode == RasterizerStorageGLES2::Shader::CanvasItem::LIGHT_MODE_UNSHADED || (blend_mode != RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX && blend_mode != RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_PMALPHA));
+	bool reclip = false;
 
-void RasterizerCanvasGLES2::initialize() {
+	if (ris.last_blend_mode != blend_mode) {
 
-	// quad buffer
-	{
-		glGenBuffers(1, &data.canvas_quad_vertices);
-		glBindBuffer(GL_ARRAY_BUFFER, data.canvas_quad_vertices);
+		switch (blend_mode) {
 
-		const float qv[8] = {
-			0, 0,
-			0, 1,
-			1, 1,
-			1, 0
-		};
+			case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX: {
+				glBlendEquation(GL_FUNC_ADD);
+				if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
+					glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+				} else {
+					glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);
+				}
 
-		glBufferData(GL_ARRAY_BUFFER, sizeof(float) * 8, qv, GL_STATIC_DRAW);
+			} break;
+			case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_ADD: {
 
-		glBindBuffer(GL_ARRAY_BUFFER, 0);
-	}
+				glBlendEquation(GL_FUNC_ADD);
+				if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
+					glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_SRC_ALPHA, GL_ONE);
+				} else {
+					glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_ZERO, GL_ONE);
+				}
 
-	// polygon buffer
-	{
-		uint32_t poly_size = GLOBAL_DEF("rendering/limits/buffers/canvas_polygon_buffer_size_kb", 128);
-		ProjectSettings::get_singleton()->set_custom_property_info("rendering/limits/buffers/canvas_polygon_buffer_size_kb", PropertyInfo(Variant::INT, "rendering/limits/buffers/canvas_polygon_buffer_size_kb", PROPERTY_HINT_RANGE, "0,256,1,or_greater"));
-		poly_size *= 1024;
-		poly_size = MAX(poly_size, (2 + 2 + 4) * 4 * sizeof(float));
-		glGenBuffers(1, &data.polygon_buffer);
-		glBindBuffer(GL_ARRAY_BUFFER, data.polygon_buffer);
-		glBufferData(GL_ARRAY_BUFFER, poly_size, NULL, GL_DYNAMIC_DRAW);
-
-		data.polygon_buffer_size = poly_size;
-
-		glBindBuffer(GL_ARRAY_BUFFER, 0);
-
-		uint32_t index_size = GLOBAL_DEF("rendering/limits/buffers/canvas_polygon_index_buffer_size_kb", 128);
-		ProjectSettings::get_singleton()->set_custom_property_info("rendering/limits/buffers/canvas_polygon_index_buffer_size_kb", PropertyInfo(Variant::INT, "rendering/limits/buffers/canvas_polygon_index_buffer_size_kb", PROPERTY_HINT_RANGE, "0,256,1,or_greater"));
-		index_size *= 1024; // kb
-		glGenBuffers(1, &data.polygon_index_buffer);
-		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, data.polygon_index_buffer);
-		glBufferData(GL_ELEMENT_ARRAY_BUFFER, index_size, NULL, GL_DYNAMIC_DRAW);
-		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-
-		data.polygon_index_buffer_size = index_size;
+			} break;
+			case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_SUB: {
+
+				glBlendEquation(GL_FUNC_REVERSE_SUBTRACT);
+				if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
+					glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_SRC_ALPHA, GL_ONE);
+				} else {
+					glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_ZERO, GL_ONE);
+				}
+			} break;
+			case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MUL: {
+				glBlendEquation(GL_FUNC_ADD);
+				if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
+					glBlendFuncSeparate(GL_DST_COLOR, GL_ZERO, GL_DST_ALPHA, GL_ZERO);
+				} else {
+					glBlendFuncSeparate(GL_DST_COLOR, GL_ZERO, GL_ZERO, GL_ONE);
+				}
+			} break;
+			case RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_PMALPHA: {
+				glBlendEquation(GL_FUNC_ADD);
+				if (storage->frame.current_rt && storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
+					glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+				} else {
+					glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);
+				}
+			} break;
+		}
 	}
 
-	// ninepatch buffers
-	{
-		// array buffer
-		glGenBuffers(1, &data.ninepatch_vertices);
-		glBindBuffer(GL_ARRAY_BUFFER, data.ninepatch_vertices);
+	state.uniforms.final_modulate = unshaded ? ci->final_modulate : Color(ci->final_modulate.r * ris.IG_modulate.r, ci->final_modulate.g * ris.IG_modulate.g, ci->final_modulate.b * ris.IG_modulate.b, ci->final_modulate.a * ris.IG_modulate.a);
 
-		glBufferData(GL_ARRAY_BUFFER, sizeof(float) * (16 + 16) * 2, NULL, GL_DYNAMIC_DRAW);
+	if (!bij.use_hardware_transform())
+		state.uniforms.modelview_matrix = Transform2D();
+	else
+		state.uniforms.modelview_matrix = ci->final_transform;
+	state.uniforms.extra_matrix = Transform2D();
 
-		glBindBuffer(GL_ARRAY_BUFFER, 0);
+	_set_uniforms();
 
-		// element buffer
-		glGenBuffers(1, &data.ninepatch_elements);
-		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, data.ninepatch_elements);
+	if (unshaded || (state.uniforms.final_modulate.a > 0.001 && (!ris.shader_cache || ris.shader_cache->canvas_item.light_mode != RasterizerStorageGLES2::Shader::CanvasItem::LIGHT_MODE_LIGHT_ONLY) && !ci->light_masked))
+		render_joined_item_commands(bij, NULL, reclip, material_ptr);
 
-#define _EIDX(y, x) (y * 4 + x)
-		uint8_t elems[3 * 2 * 9] = {
+	ris.rebind_shader = true; // hacked in for now.
 
-			// first row
+	if ((blend_mode == RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_MIX || blend_mode == RasterizerStorageGLES2::Shader::CanvasItem::BLEND_MODE_PMALPHA) && ris.IG_light && !unshaded) {
 
-			_EIDX(0, 0), _EIDX(0, 1), _EIDX(1, 1),
-			_EIDX(1, 1), _EIDX(1, 0), _EIDX(0, 0),
+		Light *light = ris.IG_light;
+		bool light_used = false;
+		VS::CanvasLightMode mode = VS::CANVAS_LIGHT_MODE_ADD;
+		state.uniforms.final_modulate = ci->final_modulate; // remove the canvas modulate
 
-			_EIDX(0, 1), _EIDX(0, 2), _EIDX(1, 2),
-			_EIDX(1, 2), _EIDX(1, 1), _EIDX(0, 1),
+		while (light) {
 
-			_EIDX(0, 2), _EIDX(0, 3), _EIDX(1, 3),
-			_EIDX(1, 3), _EIDX(1, 2), _EIDX(0, 2),
+			// use the bounding rect of the joined items, NOT only the bounding rect of the first item.
+			// note this is a cost of batching, the light culling will be less effective
+			if (ci->light_mask & light->item_mask && ris.IG_z >= light->z_min && ris.IG_z <= light->z_max && bij.bounding_rect.intersects_transformed(light->xform_cache, light->rect_cache)) {
 
-			// second row
+				//intersects this light
 
-			_EIDX(1, 0), _EIDX(1, 1), _EIDX(2, 1),
-			_EIDX(2, 1), _EIDX(2, 0), _EIDX(1, 0),
+				if (!light_used || mode != light->mode) {
 
-			// the center one would be here, but we'll put it at the end
-			// so it's easier to disable the center and be able to use
-			// one draw call for both
+					mode = light->mode;
 
-			_EIDX(1, 2), _EIDX(1, 3), _EIDX(2, 3),
-			_EIDX(2, 3), _EIDX(2, 2), _EIDX(1, 2),
+					switch (mode) {
 
-			// third row
+						case VS::CANVAS_LIGHT_MODE_ADD: {
+							glBlendEquation(GL_FUNC_ADD);
+							glBlendFunc(GL_SRC_ALPHA, GL_ONE);
+
+						} break;
+						case VS::CANVAS_LIGHT_MODE_SUB: {
+							glBlendEquation(GL_FUNC_REVERSE_SUBTRACT);
+							glBlendFunc(GL_SRC_ALPHA, GL_ONE);
+						} break;
+						case VS::CANVAS_LIGHT_MODE_MIX:
+						case VS::CANVAS_LIGHT_MODE_MASK: {
+							glBlendEquation(GL_FUNC_ADD);
+							glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+						} break;
+					}
+				}
 
-			_EIDX(2, 0), _EIDX(2, 1), _EIDX(3, 1),
-			_EIDX(3, 1), _EIDX(3, 0), _EIDX(2, 0),
+				if (!light_used) {
 
-			_EIDX(2, 1), _EIDX(2, 2), _EIDX(3, 2),
-			_EIDX(3, 2), _EIDX(3, 1), _EIDX(2, 1),
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_LIGHTING, true);
+					light_used = true;
+				}
 
-			_EIDX(2, 2), _EIDX(2, 3), _EIDX(3, 3),
-			_EIDX(3, 3), _EIDX(3, 2), _EIDX(2, 2),
+				bool has_shadow = light->shadow_buffer.is_valid() && ci->light_mask & light->item_shadow_mask;
+
+				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SHADOWS, has_shadow);
+				if (has_shadow) {
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_USE_GRADIENT, light->shadow_gradient_length > 0);
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_NEAREST, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_NONE);
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF3, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF3);
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF5, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF5);
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF7, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF7);
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF9, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF9);
+					state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF13, light->shadow_filter == VS::CANVAS_LIGHT_FILTER_PCF13);
+				}
 
-			// center field
+				state.canvas_shader.bind();
+				state.using_light = light;
+				state.using_shadow = has_shadow;
 
-			_EIDX(1, 1), _EIDX(1, 2), _EIDX(2, 2),
-			_EIDX(2, 2), _EIDX(2, 1), _EIDX(1, 1)
-		};
-#undef _EIDX
+				//always re-set uniforms, since light parameters changed
+				_set_uniforms();
+				state.canvas_shader.use_material((void *)material_ptr);
 
-		glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(elems), elems, GL_STATIC_DRAW);
+				glActiveTexture(GL_TEXTURE0 + storage->config.max_texture_image_units - 4);
+				RasterizerStorageGLES2::Texture *t = storage->texture_owner.getornull(light->texture);
+				if (!t) {
+					glBindTexture(GL_TEXTURE_2D, storage->resources.white_tex);
+				} else {
+					t = t->get_ptr();
 
-		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-	}
+					glBindTexture(t->target, t->tex_id);
+				}
+
+				glActiveTexture(GL_TEXTURE0);
+				render_joined_item_commands(bij, NULL, reclip, material_ptr); //redraw using light
+
+				state.using_light = NULL;
+			}
+
+			light = light->next_ptr;
+		}
 
-	state.canvas_shadow_shader.init();
+		if (light_used) {
 
-	state.canvas_shader.init();
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_LIGHTING, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_SHADOWS, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_NEAREST, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF3, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF5, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF7, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF9, false);
+			state.canvas_shader.set_conditional(CanvasShaderGLES2::SHADOW_FILTER_PCF13, false);
 
-	state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, true);
-	state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_RGBA_SHADOWS, storage->config.use_rgba_2d_shadows);
+			state.canvas_shader.bind();
 
-	state.canvas_shader.bind();
+			ris.last_blend_mode = -1;
 
-	state.lens_shader.init();
+			/*
+			//this is set again, so it should not be needed anyway?
+			state.canvas_item_modulate = unshaded ? ci->final_modulate : Color(
+						ci->final_modulate.r * p_modulate.r,
+						ci->final_modulate.g * p_modulate.g,
+						ci->final_modulate.b * p_modulate.b,
+						ci->final_modulate.a * p_modulate.a );
 
-	state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_PIXEL_SNAP, GLOBAL_DEF("rendering/quality/2d/use_pixel_snap", false));
 
-	state.using_light = NULL;
-	state.using_transparent_rt = false;
-	state.using_skeleton = false;
+			state.canvas_shader.set_uniform(CanvasShaderGLES2::MODELVIEW_MATRIX,state.final_transform);
+			state.canvas_shader.set_uniform(CanvasShaderGLES2::EXTRA_MATRIX,Transform2D());
+			state.canvas_shader.set_uniform(CanvasShaderGLES2::FINAL_MODULATE,state.canvas_item_modulate);
+
+			glBlendEquation(GL_FUNC_ADD);
+
+			if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_TRANSPARENT]) {
+				glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+			} else {
+				glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+			}
+
+			//@TODO RESET canvas_blend_mode
+			*/
+		}
+	}
+
+	if (reclip) {
+		glEnable(GL_SCISSOR_TEST);
+		int y = storage->frame.current_rt->height - (ris.current_clip->final_clip_rect.position.y + ris.current_clip->final_clip_rect.size.y);
+		if (storage->frame.current_rt->flags[RasterizerStorage::RENDER_TARGET_VFLIP])
+			y = ris.current_clip->final_clip_rect.position.y;
+		glScissor(ris.current_clip->final_clip_rect.position.x, y, ris.current_clip->final_clip_rect.size.width, ris.current_clip->final_clip_rect.size.height);
+	}
 }
 
-void RasterizerCanvasGLES2::finalize() {
+void RasterizerCanvasGLES2::initialize() {
+	RasterizerCanvasBaseGLES2::initialize();
+
+	// the maximum num quads in a batch is limited by GLES2. We can have only 16 bit indices,
+	// which means we can address a vertex buffer of max size 65535. 4 vertices are needed per quad.
+
+	// Note this determines the memory use by the vertex buffer vector. max quads (65536/4)-1
+	// but can be reduced to save memory if really required (will result in more batches though)
+	int max_quads = (65536 / 4) - 1;
+
+	// The sweet spot on my desktop for cache is actually smaller than the max.
+	// This saves memory too so we will use it for now, needs testing to see whether this varies according
+	// to device / platform. It could be a project/setting but is hard coded for now.
+	max_quads /= 4;
+
+	uint32_t sizeof_batch_vert = sizeof(BatchVertex);
+
+	bdata.max_quads = max_quads;
+
+	// 4 verts per quad
+	bdata.vertex_buffer_size_units = max_quads * 4;
+
+	// the index buffer can be longer than 65535, only the indices need to be within this range
+	bdata.index_buffer_size_units = max_quads * 6;
+
+	// this comes out at approx 64K for non-colored vertex buffer, and 128K for colored vertex buffer
+	bdata.vertex_buffer_size_bytes = bdata.vertex_buffer_size_units * sizeof_batch_vert;
+	bdata.index_buffer_size_bytes = bdata.index_buffer_size_units * 2; // 16 bit inds
+
+	// create equal number of norma and colored verts (as the normal may need to be translated to colored)
+	bdata.vertices.create(bdata.vertex_buffer_size_units); // 512k
+	bdata.vertices_colored.create(bdata.vertices.max_size()); // 1024k
+
+	// num batches will be auto increased dynamically if required
+	bdata.batches.create(1024);
+	bdata.batches_temp.create(bdata.batches.max_size());
+
+	// batch textures can also be increased dynamically
+	bdata.batch_textures.create(32);
+
+	// just reserve some space (may not be needed as we are orphaning, but hey ho)
+	glGenBuffers(1, &bdata.gl_vertex_buffer);
+	glBindBuffer(GL_ARRAY_BUFFER, bdata.gl_vertex_buffer);
+	glBufferData(GL_ARRAY_BUFFER, bdata.vertex_buffer_size_bytes, NULL, GL_DYNAMIC_DRAW);
+	glBindBuffer(GL_ARRAY_BUFFER, 0);
+
+	// pre fill index buffer, the indices never need to change so can be static
+	glGenBuffers(1, &bdata.gl_index_buffer);
+	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bdata.gl_index_buffer);
+
+	Vector<uint16_t> indices;
+	indices.resize(bdata.index_buffer_size_units);
+
+	for (int q = 0; q < max_quads; q++) {
+		int i_pos = q * 6; //  6 inds per quad
+		int q_pos = q * 4; // 4 verts per quad
+		indices.set(i_pos, q_pos);
+		indices.set(i_pos + 1, q_pos + 1);
+		indices.set(i_pos + 2, q_pos + 2);
+		indices.set(i_pos + 3, q_pos);
+		indices.set(i_pos + 4, q_pos + 2);
+		indices.set(i_pos + 5, q_pos + 3);
+
+		// we can only use 16 bit indices in GLES2!
+#ifdef DEBUG_ENABLED
+		CRASH_COND((q_pos + 3) > 65535);
+#endif
+	}
+
+	glBufferData(GL_ELEMENT_ARRAY_BUFFER, bdata.index_buffer_size_bytes, &indices[0], GL_STATIC_DRAW);
+	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
 }
 
 RasterizerCanvasGLES2::RasterizerCanvasGLES2() {
-#ifdef GLES_OVER_GL
-	use_nvidia_rect_workaround = GLOBAL_GET("rendering/quality/2d/gles2_use_nvidia_rect_flicker_workaround");
-#else
-	// Not needed (a priori) on GLES devices
-	use_nvidia_rect_workaround = false;
-#endif
+
+	bdata.use_batching = GLOBAL_GET("rendering/quality/2d/use_batching");
+
+	// turn off batching in the editor until it is considered stable
+	// (if the editor can't start, you can't change the use_batching project setting!)
+	if (Engine::get_singleton()->is_editor_hint()) {
+		bdata.use_batching = false;
+	}
+
+	// force on
+	//bdata.use_batching = true;
 }
diff --git a/drivers/gles2/rasterizer_canvas_gles2.h b/drivers/gles2/rasterizer_canvas_gles2.h
index f6ae6a60c05..9d4669acfc1 100644
--- a/drivers/gles2/rasterizer_canvas_gles2.h
+++ b/drivers/gles2/rasterizer_canvas_gles2.h
@@ -31,118 +31,242 @@
 #ifndef RASTERIZERCANVASGLES2_H
 #define RASTERIZERCANVASGLES2_H
 
-#include "rasterizer_storage_gles2.h"
-#include "servers/visual/rasterizer.h"
-
-#include "shaders/canvas.glsl.gen.h"
-#include "shaders/lens_distorted.glsl.gen.h"
-
-#include "shaders/canvas_shadow.glsl.gen.h"
+#include "rasterizer_canvas_base_gles2.h"
 
 class RasterizerSceneGLES2;
 
-class RasterizerCanvasGLES2 : public RasterizerCanvas {
-public:
-	enum {
-		INSTANCE_ATTRIB_BASE = 8,
-	};
-
-	struct Uniforms {
-		Transform projection_matrix;
+class RasterizerCanvasGLES2 : public RasterizerCanvasBaseGLES2 {
 
-		Transform2D modelview_matrix;
-		Transform2D extra_matrix;
-
-		Color final_modulate;
-
-		float time;
+	// used to determine whether we use hardware transform (none)
+	// software transform all verts, or software transform just a translate
+	// (no rotate or scale)
+	enum TransformMode {
+		TM_NONE,
+		TM_ALL,
+		TM_TRANSLATE,
 	};
 
-	struct Data {
-
-		GLuint canvas_quad_vertices;
-		GLuint polygon_buffer;
-		GLuint polygon_index_buffer;
-
-		uint32_t polygon_buffer_size;
-		uint32_t polygon_index_buffer_size;
-
-		GLuint ninepatch_vertices;
-		GLuint ninepatch_elements;
-
-	} data;
-
-	struct State {
-		Uniforms uniforms;
-		bool canvas_texscreen_used;
-		CanvasShaderGLES2 canvas_shader;
-		CanvasShadowShaderGLES2 canvas_shadow_shader;
-		LensDistortedShaderGLES2 lens_shader;
-
-		bool using_texture_rect;
-		bool using_ninepatch;
-		bool using_skeleton;
-
-		Transform2D skeleton_transform;
-		Transform2D skeleton_transform_inverse;
-		Size2i skeleton_texture_size;
-
-		RID current_tex;
-		RID current_normal;
-		RasterizerStorageGLES2::Texture *current_tex_ptr;
+	// pod versions of vector and color and RID, need to be 32 bit for vertex format
+	struct BatchVector2 {
+		float x, y;
+		void set(const Vector2 &o) {
+			x = o.x;
+			y = o.y;
+		}
+		void to(Vector2 &o) const {
+			o.x = x;
+			o.y = y;
+		}
+	};
 
-		Transform vp;
-		Light *using_light;
-		bool using_shadow;
-		bool using_transparent_rt;
+	struct BatchColor {
+		float r, g, b, a;
+		void set(const Color &c) {
+			r = c.r;
+			g = c.g;
+			b = c.b;
+			a = c.a;
+		}
+		bool equals(const Color &c) const {
+			return (r == c.r) && (g == c.g) && (b == c.b) && (a == c.a);
+		}
+		const float *get_data() const { return &r; }
+	};
 
-	} state;
+	struct BatchVertex {
+		// must be 32 bit pod
+		BatchVector2 pos;
+		BatchVector2 uv;
+	};
 
-	typedef void Texture;
+	struct BatchVertexColored : public BatchVertex {
+		// must be 32 bit pod
+		BatchColor col;
+	};
 
-	RasterizerSceneGLES2 *scene_render;
+	struct Batch {
+		enum CommandType : uint32_t {
+			BT_DEFAULT,
+			BT_RECT,
+		};
+
+		CommandType type;
+		uint32_t first_command; // also item reference number
+		uint32_t num_commands;
+		uint32_t first_quad;
+		uint32_t batch_texture_id;
+		BatchColor color;
+	};
 
-	RasterizerStorageGLES2 *storage;
+	struct BatchTex {
+		enum TileMode : uint32_t {
+			TILE_OFF,
+			TILE_NORMAL,
+			TILE_FORCE_REPEAT,
+		};
+		RID RID_texture;
+		RID RID_normal;
+		TileMode tile_mode;
+		BatchVector2 tex_pixel_size;
+	};
 
-	bool use_nvidia_rect_workaround;
+	// batch item may represent 1 or more items
+	struct BItemJoined {
+		uint32_t first_item_ref;
+		uint32_t num_item_refs;
 
-	virtual RID light_internal_create();
-	virtual void light_internal_update(RID p_rid, Light *p_light);
-	virtual void light_internal_free(RID p_rid);
+		Rect2 bounding_rect;
 
-	void _set_uniforms();
+		// we are always splitting items with lots of commands,
+		// and items with unhandled primitives (default)
+		bool use_hardware_transform() const { return num_item_refs == 1; }
+	};
 
-	virtual void canvas_begin();
-	virtual void canvas_end();
+	struct BItemRef {
+		Item *m_pItem;
+	};
 
-	_FORCE_INLINE_ void _draw_gui_primitive(int p_points, const Vector2 *p_vertices, const Color *p_colors, const Vector2 *p_uvs);
-	_FORCE_INLINE_ void _draw_polygon(const int *p_indices, int p_index_count, int p_vertex_count, const Vector2 *p_vertices, const Vector2 *p_uvs, const Color *p_colors, bool p_singlecolor, const float *p_weights = NULL, const int *p_bones = NULL);
-	_FORCE_INLINE_ void _draw_generic(GLuint p_primitive, int p_vertex_count, const Vector2 *p_vertices, const Vector2 *p_uvs, const Color *p_colors, bool p_singlecolor);
-	_FORCE_INLINE_ void _draw_generic_indices(GLuint p_primitive, const int *p_indices, int p_index_count, int p_vertex_count, const Vector2 *p_vertices, const Vector2 *p_uvs, const Color *p_colors, bool p_singlecolor);
+	struct BatchData {
+		void reset_flush() {
+			batches.reset();
+			batch_textures.reset();
+			vertices.reset();
+
+			total_quads = 0;
+			total_color_changes = 0;
+		}
+
+		GLuint gl_vertex_buffer;
+		GLuint gl_index_buffer;
+
+		uint32_t max_quads;
+		uint32_t vertex_buffer_size_units;
+		uint32_t vertex_buffer_size_bytes;
+		uint32_t index_buffer_size_units;
+		uint32_t index_buffer_size_bytes;
+
+		RasterizerArray<BatchVertex> vertices;
+		RasterizerArray<BatchVertexColored> vertices_colored;
+		RasterizerArray<Batch> batches;
+		RasterizerArray<Batch> batches_temp; // used for translating to colored vertex batches
+		RasterizerArray_non_pod<BatchTex> batch_textures; // the only reason this is non-POD is because of RIDs
+
+		bool use_colored_vertices;
+		bool use_batching;
+
+		RasterizerArray<BItemJoined> items_joined;
+		RasterizerArray<BItemRef> item_refs;
+
+		// counts
+		int total_quads;
+
+		// we keep a record of how many color changes caused new batches
+		// if the colors are causing an excessive number of batches, we switch
+		// to alternate batching method and add color to the vertex format.
+		int total_color_changes;
+	} bdata;
+
+	// RenderItemState
+	struct RIState {
+		RIState() {
+			current_clip = NULL;
+			shader_cache = NULL;
+			rebind_shader = true;
+			prev_use_skeleton = false;
+			last_blend_mode = -1;
+			canvas_last_material = RID();
+		}
+		Item *current_clip;
+		RasterizerStorageGLES2::Shader *shader_cache;
+		bool rebind_shader;
+		bool prev_use_skeleton;
+		int last_blend_mode;
+		RID canvas_last_material;
+
+		// IG is item group (data over a single call to canvas_render_items)
+		int IG_z;
+		Color IG_modulate;
+		Light *IG_light;
+		Transform2D IG_base_transform;
+	};
 
-	_FORCE_INLINE_ void _canvas_item_render_commands(Item *p_item, Item *current_clip, bool &reclip, RasterizerStorageGLES2::Material *p_material);
-	void _copy_screen(const Rect2 &p_rect);
-	_FORCE_INLINE_ void _copy_texscreen(const Rect2 &p_rect);
+	struct FillState {
+		void reset() {
+			curr_batch = 0;
+			batch_tex_id = -1;
+			use_hardware_transform = true;
+			texpixel_size = Vector2(1, 1);
+		}
+		Batch *curr_batch;
+		int batch_tex_id;
+		bool use_hardware_transform;
+		Vector2 texpixel_size;
+	};
 
+public:
 	virtual void canvas_render_items(Item *p_item_list, int p_z, const Color &p_modulate, Light *p_light, const Transform2D &p_base_transform);
-	virtual void canvas_debug_viewport_shadows(Light *p_lights_with_shadow);
-
-	virtual void canvas_light_shadow_buffer_update(RID p_buffer, const Transform2D &p_light_xform, int p_light_mask, float p_near, float p_far, LightOccluderInstance *p_occluders, CameraMatrix *p_xform_cache);
 
-	virtual void reset_canvas();
-
-	RasterizerStorageGLES2::Texture *_bind_canvas_texture(const RID &p_texture, const RID &p_normal_map);
+private:
+	void _canvas_render_item(Item *ci, RIState &ris);
+	_FORCE_INLINE_ void _canvas_item_render_commands(Item *p_item, Item *current_clip, bool &reclip, RasterizerStorageGLES2::Material *p_material);
 
-	void _bind_quad_buffer();
-	void draw_generic_textured_rect(const Rect2 &p_rect, const Rect2 &p_src);
-	void draw_lens_distortion_rect(const Rect2 &p_rect, float p_k1, float p_k2, const Vector2 &p_eye_center, float p_oversample);
+	// high level batch funcs
+	void canvas_render_items_implementation(Item *p_item_list, int p_z, const Color &p_modulate, Light *p_light, const Transform2D &p_base_transform);
+	void render_joined_item(const BItemJoined &bij, RIState &ris);
+	void join_items(Item *p_item_list, int p_z, const Color &p_modulate, Light *p_light, const Transform2D &p_base_transform);
+	bool try_join_item(Item *ci, RIState &ris, bool &r_batch_break);
+	void render_joined_item_commands(const BItemJoined &bij, Item *current_clip, bool &reclip, RasterizerStorageGLES2::Material *p_material);
+	void render_batches(Item::Command *const *commands, int first_item_ref_id, Item *current_clip, bool &reclip, RasterizerStorageGLES2::Material *p_material);
+	bool prefill_joined_item(FillState &fill_state, int &r_command_start, Item *p_item, Item *current_clip, bool &reclip, RasterizerStorageGLES2::Material *p_material);
+	void flush_render_batches(Item *p_item, Item *current_clip, bool &reclip, RasterizerStorageGLES2::Material *p_material);
+
+	// low level batch funcs
+	void _batch_translate_to_colored();
+	_FORCE_INLINE_ int _batch_find_or_create_tex(const RID &p_texture, const RID &p_normal, bool p_tile, int p_previous_match);
+	RasterizerStorageGLES2::Texture *_get_canvas_texture(const RID &p_texture) const;
+	void _batch_upload_buffers();
+	void _batch_render_rects(const Batch &batch, RasterizerStorageGLES2::Material *p_material);
+	BatchVertex *_batch_vertex_request_new() { return bdata.vertices.request(); }
+	Batch *_batch_request_new(bool p_blank = true);
+
+	bool _detect_batch_break(Item *ci);
+	void _software_transform_vertex(BatchVector2 &v, const Transform2D &tr) const;
+	void _software_transform_vertex(Vector2 &v, const Transform2D &tr) const;
+	TransformMode _find_transform_mode(bool p_use_hardware_transform, const Transform2D &p_tr, Transform2D &r_tr) const;
 
+public:
 	void initialize();
-	void finalize();
-
-	virtual void draw_window_margins(int *black_margin, RID *black_image);
-
 	RasterizerCanvasGLES2();
 };
 
+//////////////////////////////////////////////////////////////
+
+inline void RasterizerCanvasGLES2::_software_transform_vertex(BatchVector2 &v, const Transform2D &tr) const {
+	Vector2 vc(v.x, v.y);
+	vc = tr.xform(vc);
+	v.set(vc);
+}
+
+inline void RasterizerCanvasGLES2::_software_transform_vertex(Vector2 &v, const Transform2D &tr) const {
+	v = tr.xform(v);
+}
+
+inline RasterizerCanvasGLES2::TransformMode RasterizerCanvasGLES2::_find_transform_mode(bool p_use_hardware_transform, const Transform2D &p_tr, Transform2D &r_tr) const {
+	if (!p_use_hardware_transform) {
+		r_tr = p_tr;
+
+		// decided whether to do translate only for software transform
+		if ((p_tr.elements[0].x == 1.0) &&
+				(p_tr.elements[0].y == 0.0) &&
+				(p_tr.elements[1].x == 0.0) &&
+				(p_tr.elements[1].y == 1.0)) {
+			return TM_TRANSLATE;
+		} else {
+			return TM_ALL;
+		}
+	}
+
+	return TM_NONE;
+}
+
 #endif // RASTERIZERCANVASGLES2_H
diff --git a/servers/visual_server.cpp b/servers/visual_server.cpp
index 19b9e2c783c..18b4f206820 100644
--- a/servers/visual_server.cpp
+++ b/servers/visual_server.cpp
@@ -2374,6 +2374,7 @@ VisualServer::VisualServer() {
 	GLOBAL_DEF_RST("rendering/vram_compression/import_etc2", true);
 	GLOBAL_DEF_RST("rendering/vram_compression/import_pvrtc", false);
 
+	GLOBAL_DEF("rendering/quality/2d/use_batching", false);
 	GLOBAL_DEF("rendering/quality/directional_shadow/size", 4096);
 	GLOBAL_DEF("rendering/quality/directional_shadow/size.mobile", 2048);
 	ProjectSettings::get_singleton()->set_custom_property_info("rendering/quality/directional_shadow/size", PropertyInfo(Variant::INT, "rendering/quality/directional_shadow/size", PROPERTY_HINT_RANGE, "256,16384"));

